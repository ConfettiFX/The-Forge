#include "ProfilerUI.h"

#if PROFILE_ENABLED

#include "ProfilerBase.h"

#include "../EASTL/sort.h"


#include "../../../OS/Interfaces/ILog.h"
#include "../../../OS/Interfaces/IFileSystem.h"

// Globals needed for microprofiler UI


struct ProfileStringArray
{
	const char* ppStrings[PROFILE_TOOLTIP_MAX_STRINGS];
	char Buffer[PROFILE_TOOLTIP_STRING_BUFFER_SIZE];
	char* pBufferPos;
	uint32_t nNumStrings;
};

struct ProfileGroupMenuItem
{
	uint32_t nIsCategory;
	uint32_t nCategoryIndex;
	uint32_t nIndex;
	const char* pName;
};

struct ProfileCustom
{
	char pName[PROFILE_NAME_MAX_LEN];
	uint32_t nFlags;
	uint32_t nAggregateFlip;
	uint32_t nNumTimers;
	uint32_t nMaxTimers;
	uint64_t nGroupMask;
	float fReference;
	uint64_t* pTimers;
};

struct SOptionDesc
{
	SOptionDesc() {}
	SOptionDesc(uint8_t nSubType, uint8_t nIndex, const char* fmt, ...) :nSubType(nSubType), nIndex(nIndex)
	{
		va_list args;
		va_start(args, fmt);
		vsprintf(Text, fmt, args);
		va_end(args);
	}
	char Text[32];
	uint8_t nSubType;
	uint8_t nIndex;
	bool bSelected;
};

static uint32_t g_ProfileAggregatePresets[] = { 0, 10, 20, 30, 60, 120 };
static float g_ProfileReferenceTimePresets[] = { 5.f, 10.f, 15.f,20.f, 33.33f, 66.66f, 100.f, 250.f, 500.f, 1000.f };
static uint32_t g_ProfileOpacityPresets[] = { 0x40, 0x80, 0xc0, 0xff };
static const char* g_ProfilePresetNames[] =
{
	PROFILE_DEFAULT_PRESET,
	"Render",
	"GPU",
	"Lighting",
	"AI",
	"Visibility",
	"Sound",
};

enum
{
	PROFILE_NUM_REFERENCE_PRESETS = sizeof(g_ProfileReferenceTimePresets) / sizeof(g_ProfileReferenceTimePresets[0]),
	PROFILE_NUM_OPACITY_PRESETS = sizeof(g_ProfileOpacityPresets) / sizeof(g_ProfileOpacityPresets[0]),
#if PROFILE_CONTEXT_SWITCH_TRACE
	PROFILE_OPTION_SIZE = PROFILE_NUM_REFERENCE_PRESETS + PROFILE_NUM_OPACITY_PRESETS * 2 + 2 + 6,
#else
	PROFILE_OPTION_SIZE = PROFILE_NUM_REFERENCE_PRESETS + PROFILE_NUM_OPACITY_PRESETS * 2 + 2 + 3,
#endif
};

struct ProfileUI
{
	//menu/mouse over stuff
	uint64_t nHoverToken;
	int64_t  nHoverTime;
	int 	 nHoverFrame;
#if PROFILE_DEBUG
	uint64_t nHoverAddressEnter;
	uint64_t nHoverAddressLeave;
#endif

	uint32_t nWidth;
	uint32_t nHeight;

	int nOffsetX[P_DRAW_SIZE];
	int nOffsetY[P_DRAW_SIZE];

	float fDetailedOffset; //display offset relative to start of latest displayable frame.
	float fDetailedRange; //no. of ms to display
	float fDetailedOffsetTarget;
	float fDetailedRangeTarget;
	uint32_t nOpacityBackground;
	uint32_t nOpacityForeground;
	bool bShowSpikes;



	uint32_t 				nMouseX;
	uint32_t 				nMouseY;
	uint32_t 				nMouseDownX;
	uint32_t 				nMouseDownY;
	int						nMouseWheelDelta;
	uint32_t				nMouseDownLeft;
	uint32_t				nMouseDownRight;
	uint32_t 				nMouseLeft;
	uint32_t 				nMouseRight;
	uint32_t 				nMouseLeftMod;
	uint32_t 				nMouseRightMod;
	uint32_t				nModDown;
	uint32_t 				nActiveMenu;

	ProfileLogEntry*	pDisplayMouseOver;
	uint64_t				nDisplayMouseOverTimerIndex;

	int64_t					nRangeBegin;
	int64_t					nRangeEnd;
	int64_t					nRangeBeginGpu;
	int64_t					nRangeEndGpu;
	uint32_t				nRangeBeginIndex;
	uint32_t 				nRangeEndIndex;
	ProfileThreadLog* 	pRangeLog;
	uint32_t				nHoverColor;
	uint32_t				nHoverColorShared;

	int64_t					nTickReferenceCpu;
	int64_t					nTickReferenceGpu;

	ProfileStringArray LockedToolTips[PROFILE_TOOLTIP_MAX_LOCKED];
	uint32_t  				nLockedToolTipColor[PROFILE_TOOLTIP_MAX_LOCKED];
	int 					LockedToolTipFront;

	ProfileGroupMenuItem 	GroupMenu[PROFILE_MAX_GROUPS + PROFILE_MAX_CATEGORIES];
	uint32_t 					GroupMenuCount;


	uint32_t					nCustomActive;
	uint32_t					nCustomTimerCount;
	uint32_t 					nCustomCount;
	ProfileCustom 			Custom[PROFILE_CUSTOM_MAX];
	uint64_t					CustomTimer[PROFILE_CUSTOM_MAX_TIMERS];

	SOptionDesc Options[PROFILE_OPTION_SIZE];

	uint32_t nCounterWidth;
	uint32_t nLimitWidth;
	uint32_t nCounterWidthTemp;
	uint32_t nLimitWidthTemp;


};

static ProfileUI g_ProfileUI;
static uint32_t g_nProfileBackColors[2] = { 0x474747, 0x313131 };
#define PROFILE_NUM_CONTEXT_SWITCH_COLORS 16
static uint32_t g_nProfileContextSwitchThreadColors[PROFILE_NUM_CONTEXT_SWITCH_COLORS] = //palette generated by http://tools.medialab.sciences-po.fr/iwanthue/index.php
{
	0x63607B,
	0x755E2B,
	0x326A55,
	0x523135,
	0x904F42,
	0x87536B,
	0x346875,
	0x5E6046,
	0x35404C,
	0x224038,
	0x413D1E,
	0x5E3A26,
	0x5D6161,
	0x4C6234,
	0x7D564F,
	0x5C4352,
};


void ProfileInitUI()
{
	static bool bInitialized = false;
	if (!bInitialized)
	{
        ProfileUI & UI = g_ProfileUI;
		bInitialized = true;
		memset(&g_ProfileUI, 0, sizeof(g_ProfileUI));
#if defined(TARGET_IOS)
        UI.nMouseX = UI.nMouseY = 100000; // So we don't have something selected from the get go
#endif
		UI.nActiveMenu = (uint32_t)-1;
		UI.fDetailedOffsetTarget = UI.fDetailedOffset = 0.f;
		UI.fDetailedRangeTarget = UI.fDetailedRange = 50.f;

		UI.nOpacityBackground = 0xffu << 24;
		UI.nOpacityForeground = 0xffu << 24;

		UI.bShowSpikes = false;

		UI.nWidth = 100;
		UI.nHeight = 100;

		UI.nCustomActive = (uint32_t)-1;
		UI.nCustomTimerCount = 0;
		UI.nCustomCount = 0;

		int nIndex = 0;
		UI.Options[nIndex++] = SOptionDesc(0xff, 0, "%s", "Reference");
		for (int i = 0; i < PROFILE_NUM_REFERENCE_PRESETS; ++i)
		{
			UI.Options[nIndex++] = SOptionDesc(0, i, "  %6.2fms", g_ProfileReferenceTimePresets[i]);
		}
		UI.Options[nIndex++] = SOptionDesc(0xff, 0, "%s", "BG Opacity");
		for (int i = 0; i < PROFILE_NUM_OPACITY_PRESETS; ++i)
		{
			UI.Options[nIndex++] = SOptionDesc(1, i, "  %7d%%", (i + 1) * 25);
		}
		UI.Options[nIndex++] = SOptionDesc(0xff, 0, "%s", "FG Opacity");
		for (int i = 0; i < PROFILE_NUM_OPACITY_PRESETS; ++i)
		{
			UI.Options[nIndex++] = SOptionDesc(2, i, "  %7d%%", (i + 1) * 25);
		}
		UI.Options[nIndex++] = SOptionDesc(0xff, 0, "%s", "Spike Display");
		UI.Options[nIndex++] = SOptionDesc(3, 0, "%s", "  Enable");

#if PROFILE_CONTEXT_SWITCH_TRACE
		UI.Options[nIndex++] = SOptionDesc(0xff, 0, "%s", "CSwitch Trace");
		UI.Options[nIndex++] = SOptionDesc(4, 0, "%s", "  All Threads");
		UI.Options[nIndex++] = SOptionDesc(4, 1, "%s", "  No Bars");
#endif
		ASSERT(nIndex == PROFILE_OPTION_SIZE);

		UI.nCounterWidth = 100;
		UI.nLimitWidth = 100;
		UI.nCounterWidthTemp = 100;
		UI.nLimitWidthTemp = 100;

	}
}

void ProfileSetDisplayMode(int nValue)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	nValue = nValue >= 0 && nValue < P_DRAW_SIZE ? nValue : S.nDisplay;
	S.nDisplay = nValue;
	UI.nOffsetY[S.nDisplay] = 0;
}

void ProfileToggleDisplayMode()
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	S.nDisplay = (S.nDisplay + 1) % P_DRAW_SIZE;
	UI.nOffsetY[S.nDisplay] = 0;
}


void ProfileStringArrayClear(ProfileStringArray* pArray)
{
	pArray->nNumStrings = 0;
	pArray->pBufferPos = &pArray->Buffer[0];
}

void ProfileStringArrayAddLiteral(ProfileStringArray* pArray, const char* pLiteral)
{
	ASSERT(pArray->nNumStrings < PROFILE_TOOLTIP_MAX_STRINGS);
	pArray->ppStrings[pArray->nNumStrings++] = pLiteral;
}

void ProfileStringArrayFormat(ProfileStringArray* pArray, const char* fmt, ...)
{
	ASSERT(pArray->nNumStrings < PROFILE_TOOLTIP_MAX_STRINGS);
	pArray->ppStrings[pArray->nNumStrings++] = pArray->pBufferPos;
	va_list args;
	va_start(args, fmt);
	pArray->pBufferPos += 1 + vsprintf(pArray->pBufferPos, fmt, args);
	va_end(args);
	ASSERT(pArray->pBufferPos < pArray->Buffer + PROFILE_TOOLTIP_STRING_BUFFER_SIZE);
}
void ProfileStringArrayCopy(ProfileStringArray* pDest, ProfileStringArray* pSrc)
{
	memcpy(&pDest->ppStrings[0], &pSrc->ppStrings[0], sizeof(pDest->ppStrings));
	memcpy(&pDest->Buffer[0], &pSrc->Buffer[0], sizeof(pDest->Buffer));
	for (uint32_t i = 0; i < PROFILE_TOOLTIP_MAX_STRINGS; ++i)
	{
		if (i < pSrc->nNumStrings)
		{
			if (pSrc->ppStrings[i] >= &pSrc->Buffer[0] && pSrc->ppStrings[i] < &pSrc->Buffer[0] + PROFILE_TOOLTIP_STRING_BUFFER_SIZE)
			{
				pDest->ppStrings[i] += &pDest->Buffer[0] - &pSrc->Buffer[0];
			}
		}
	}
	pDest->nNumStrings = pSrc->nNumStrings;
}

void ProfileFloatWindowSize(const char** ppStrings, uint32_t nNumStrings, uint32_t* pColors, uint32_t& nWidth, uint32_t& nHeight, uint32_t* pStringLengths = 0)
{
	uint32_t* nStringLengths = pStringLengths ? pStringLengths : (uint32_t*)alloca(nNumStrings * sizeof(uint32_t));
	uint32_t nTextCount = nNumStrings / 2;
	for (uint32_t i = 0; i < nTextCount; ++i)
	{
		uint32_t i0 = i * 2;
		uint32_t s0, s1;
		nStringLengths[i0] = s0 = (uint32_t)strlen(ppStrings[i0]);
		nStringLengths[i0 + 1] = s1 = (uint32_t)strlen(ppStrings[i0 + 1]);
		nWidth = ProfileMax(s0 + s1, nWidth);
	}
	nWidth = (PROFILE_TEXT_WIDTH + 1) * (2 + nWidth) + 2 * PROFILE_BORDER_SIZE;
	if (pColors)
		nWidth += PROFILE_TEXT_WIDTH + 1;
	nHeight = (PROFILE_TEXT_HEIGHT + 1) * nTextCount + 2 * PROFILE_BORDER_SIZE;
}

void ProfileDrawFloatWindow(uint32_t nX, uint32_t nY, const char** ppStrings, uint32_t nNumStrings, uint32_t nColor, uint32_t* pColors = 0)
{
    ProfileUI & UI = g_ProfileUI;
	uint32_t nWidth = 0, nHeight = 0;
	uint32_t* nStringLengths = (uint32_t*)alloca(nNumStrings * sizeof(uint32_t));
	ProfileFloatWindowSize(ppStrings, nNumStrings, pColors, nWidth, nHeight, nStringLengths);
	uint32_t nTextCount = nNumStrings / 2;
	if (nX + nWidth > UI.nWidth)
		nX = UI.nWidth - nWidth;
	if (nY + nHeight > UI.nHeight)
		nY = UI.nHeight - nHeight;
	ProfileDrawBox(nX - 1, nY - 1, nX + nWidth + 1, nY + nHeight + 1, 0xff000000 | nColor, ProfileBoxTypeFlat);
	ProfileDrawBox(nX, nY, nX + nWidth, nY + nHeight, 0xff000000, ProfileBoxTypeFlat);
	if (pColors)
	{
		nX += PROFILE_TEXT_WIDTH + 1;
		nWidth -= PROFILE_TEXT_WIDTH + 1;
	}
	for (uint32_t i = 0; i < nTextCount; ++i)
	{
		int i0 = i * 2;
		if (pColors)
		{
			ProfileDrawBox(nX - PROFILE_TEXT_WIDTH, nY, nX, nY + PROFILE_TEXT_WIDTH, pColors[i] | 0xff000000, ProfileBoxTypeFlat);
		}
		ProfileDrawText(nX + 1, nY + 1, (uint32_t)-1, ppStrings[i0], (uint32_t)strlen(ppStrings[i0]));
		ProfileDrawText(nX + nWidth - nStringLengths[i0 + 1] * (PROFILE_TEXT_WIDTH + 1), nY + 1, (uint32_t)-1, ppStrings[i0 + 1], (uint32_t)strlen(ppStrings[i0 + 1]));
		nY += (PROFILE_TEXT_HEIGHT + 1);
	}
}

void ProfileDrawTextBackground(uint32_t nX, uint32_t nY, uint32_t nColor, uint32_t nBgColor, const char* pString, uint32_t nStrLen)
{
	uint32_t nWidth = (PROFILE_TEXT_WIDTH + 1) * (nStrLen)+2 * PROFILE_BORDER_SIZE;
	uint32_t nHeight = (PROFILE_TEXT_HEIGHT + 1);
	ProfileDrawBox(nX, nY, nX + nWidth, nY + nHeight, nBgColor, ProfileBoxTypeFlat);
	ProfileDrawText(nX, nY, nColor, pString, nStrLen);
}

void ProfileToolTipMeta(ProfileStringArray* pToolTip)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	if (UI.nRangeBeginIndex != UI.nRangeEndIndex && UI.pRangeLog)
	{
		uint64_t nMetaSum[PROFILE_META_MAX] = { 0 };
		uint64_t nMetaSumInclusive[PROFILE_META_MAX] = { 0 };
		int nStackDepth = 0;
		uint32_t nRange[2][2];
		ProfileThreadLog* pLog = UI.pRangeLog;


		ProfileGetRange(UI.nRangeEndIndex, UI.nRangeBeginIndex, nRange);
		for (uint32_t i = 0; i < 2; ++i)
		{
			uint32_t nStart = nRange[i][0];
			uint32_t nEnd = nRange[i][1];
			for (uint32_t j = nStart; j < nEnd; ++j)
			{
				ProfileLogEntry LE = pLog->Log[j];
				uint64_t nType = ProfileLogType(LE);
				switch (nType)
				{
				case P_LOG_META:
				{
					int64_t nMetaIndex = ProfileLogTimerIndex(LE);
					int64_t nMetaCount = ProfileLogGetTick(LE);
					ASSERT(nMetaIndex < PROFILE_META_MAX);
					if (nStackDepth > 1)
					{
						nMetaSumInclusive[nMetaIndex] += nMetaCount;
					}
					else
					{
						nMetaSum[nMetaIndex] += nMetaCount;
					}
				}
				break;
				case P_LOG_LEAVE:
					if (nStackDepth)
					{
						nStackDepth--;
					}
					else
					{
						for (int i = 0; i < PROFILE_META_MAX; ++i)
						{
							nMetaSumInclusive[i] += nMetaSum[i];
							nMetaSum[i] = 0;
						}
					}
					break;
				case P_LOG_ENTER:
					nStackDepth++;
					break;
				}

			}
		}
		bool bSpaced = false;
		for (int i = 0; i < PROFILE_META_MAX; ++i)
		{
			if (S.MetaCounters[i].pName && (nMetaSum[i] || nMetaSumInclusive[i]))
			{
				if (!bSpaced)
				{
					bSpaced = true;
					ProfileStringArrayAddLiteral(pToolTip, "");
					ProfileStringArrayAddLiteral(pToolTip, "");
				}
				ProfileStringArrayFormat(pToolTip, "%s excl", S.MetaCounters[i].pName);
				ProfileStringArrayFormat(pToolTip, "%5lld", (long long)nMetaSum[i]);
				ProfileStringArrayFormat(pToolTip, "%s incl", S.MetaCounters[i].pName);
				ProfileStringArrayFormat(pToolTip, "%5lld", (long long)(nMetaSum[i] + nMetaSumInclusive[i]));
			}
		}
	}
}

void ProfileToolTipLabel(ProfileStringArray* pToolTip)
{
    ProfileUI & UI = g_ProfileUI;
	if (UI.nRangeBeginIndex != UI.nRangeEndIndex && UI.pRangeLog)
	{
		bool bSpaced = false;
		int nStackDepth = 0;
		uint32_t nRange[2][2];
		ProfileThreadLog* pLog = UI.pRangeLog;

		ProfileGetRange(UI.nRangeEndIndex, UI.nRangeBeginIndex, nRange);
		for (uint32_t i = 0; i < 2; ++i)
		{
			uint32_t nStart = nRange[i][0];
			uint32_t nEnd = nRange[i][1];
			for (uint32_t j = nStart; j < nEnd; ++j)
			{
				ProfileLogEntry LE = pLog->Log[j];
				uint32_t nType = (uint32_t)ProfileLogType(LE);
				switch (nType)
				{
				case P_LOG_LABEL:
				case P_LOG_LABEL_LITERAL:
				{
					if (nStackDepth == 1)
					{
						uint64_t nLabel = ProfileLogGetTick(LE);
						const char* pLabelName = ProfileGetLabel(nType, nLabel);

						if (!bSpaced)
						{
							bSpaced = true;
							ProfileStringArrayAddLiteral(pToolTip, "");
							ProfileStringArrayAddLiteral(pToolTip, "");
						}

						if (pToolTip->nNumStrings + 2 <= PROFILE_TOOLTIP_MAX_STRINGS)
						{
							ProfileStringArrayAddLiteral(pToolTip, "Label:");
							ProfileStringArrayAddLiteral(pToolTip, pLabelName ? pLabelName : "??");
						}
					}
				}
				break;
				case P_LOG_LEAVE:
					if (nStackDepth)
					{
						nStackDepth--;
					}
					break;
				case P_LOG_ENTER:
					nStackDepth++;
					break;
				}

			}
		}
	}
}

void ProfileDrawFloatTooltip(uint32_t nX, uint32_t nY, uint32_t nToken, uint64_t nTime)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	uint32_t nIndex = ProfileGetTimerIndex(nToken);
	uint32_t nAggregateFrames = S.nAggregateFrames ? S.nAggregateFrames : 1;
	uint32_t nAggregateCount = S.Aggregate[nIndex].nCount ? S.Aggregate[nIndex].nCount : 1;

	uint32_t nGroupId = ProfileGetGroupIndex(nToken);
	uint32_t nTimerId = ProfileGetTimerIndex(nToken);
	bool bGpu = S.GroupInfo[nGroupId].Type == ProfileTokenTypeGpu;

	float fToMs = ProfileTickToMsMultiplier(bGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu());

	float fMs = fToMs * (nTime);
	float fFrameMs = fToMs * (S.Frame[nIndex].nTicks);
	float fAverage = fToMs * (S.Aggregate[nIndex].nTicks / nAggregateFrames);
	float fCallAverage = fToMs * (S.Aggregate[nIndex].nTicks / nAggregateCount);
	float fMax = fToMs * (S.AggregateMax[nIndex]);
	float fMin = fToMs * (S.AggregateMin[nIndex]);

	float fFrameMsExclusive = fToMs * (S.FrameExclusive[nIndex]);
	float fAverageExclusive = fToMs * (S.AggregateExclusive[nIndex] / nAggregateFrames);
	float fMaxExclusive = fToMs * (S.AggregateMaxExclusive[nIndex]);

	float fGroupAverage = fToMs * (S.AggregateGroup[nGroupId] / nAggregateFrames);
	float fGroupMax = fToMs * (S.AggregateGroupMax[nGroupId]);
	float fGroup = fToMs * (S.FrameGroup[nGroupId]);


	ProfileStringArray ToolTip;
	ProfileStringArrayClear(&ToolTip);
	const char* pGroupName = S.GroupInfo[nGroupId].pName;
	const char* pTimerName = S.TimerInfo[nTimerId].pName;
	ProfileStringArrayAddLiteral(&ToolTip, "Timer:");
	ProfileStringArrayFormat(&ToolTip, "%s", pTimerName);

#if PROFILE_DEBUG
	ProfileStringArrayFormat(&ToolTip, "0x%p", UI.nHoverAddressEnter);
	ProfileStringArrayFormat(&ToolTip, "0x%p", UI.nHoverAddressLeave);
#endif

	if (nTime != (uint64_t)0)
	{
		ProfileStringArrayAddLiteral(&ToolTip, "Time:");
		ProfileStringArrayFormat(&ToolTip, "%6.3fms", fMs);
		ProfileStringArrayAddLiteral(&ToolTip, "");
		ProfileStringArrayAddLiteral(&ToolTip, "");
	}

	ProfileStringArrayAddLiteral(&ToolTip, "Frame Time:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fFrameMs);

	ProfileStringArrayAddLiteral(&ToolTip, "Average:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fAverage);

	ProfileStringArrayAddLiteral(&ToolTip, "Max:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fMax);

	ProfileStringArrayAddLiteral(&ToolTip, "Min:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fMin);

	ProfileStringArrayAddLiteral(&ToolTip, "");
	ProfileStringArrayAddLiteral(&ToolTip, "");

	ProfileStringArrayAddLiteral(&ToolTip, "Call Average:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fCallAverage);

	ProfileStringArrayAddLiteral(&ToolTip, "Call Count:");
	ProfileStringArrayFormat(&ToolTip, "%6.2f", double(nAggregateCount) / nAggregateFrames);

	ProfileStringArrayAddLiteral(&ToolTip, "");
	ProfileStringArrayAddLiteral(&ToolTip, "");

	ProfileStringArrayAddLiteral(&ToolTip, "Exclusive Frame Time:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fFrameMsExclusive);

	ProfileStringArrayAddLiteral(&ToolTip, "Exclusive Average:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fAverageExclusive);

	ProfileStringArrayAddLiteral(&ToolTip, "Exclusive Max:");
	ProfileStringArrayFormat(&ToolTip, "%6.3fms", fMaxExclusive);

	ProfileStringArrayAddLiteral(&ToolTip, "");
	ProfileStringArrayAddLiteral(&ToolTip, "");

	ProfileStringArrayAddLiteral(&ToolTip, "Group:");
	ProfileStringArrayFormat(&ToolTip, "%s", pGroupName);
	ProfileStringArrayAddLiteral(&ToolTip, "Frame Time:");
	ProfileStringArrayFormat(&ToolTip, "%6.3f", fGroup);
	ProfileStringArrayAddLiteral(&ToolTip, "Frame Average:");
	ProfileStringArrayFormat(&ToolTip, "%6.3f", fGroupAverage);
	ProfileStringArrayAddLiteral(&ToolTip, "Frame Max:");
	ProfileStringArrayFormat(&ToolTip, "%6.3f", fGroupMax);

	ProfileToolTipMeta(&ToolTip);
	ProfileToolTipLabel(&ToolTip);

	ProfileDrawFloatWindow(nX, nY + 20, &ToolTip.ppStrings[0], ToolTip.nNumStrings, S.TimerInfo[nTimerId].nColor);

	if (UI.nMouseLeftMod)
	{
		int nIndex = (g_ProfileUI.LockedToolTipFront + PROFILE_TOOLTIP_MAX_LOCKED - 1) % PROFILE_TOOLTIP_MAX_LOCKED;
		g_ProfileUI.nLockedToolTipColor[nIndex] = S.TimerInfo[nTimerId].nColor;
		ProfileStringArrayCopy(&g_ProfileUI.LockedToolTips[nIndex], &ToolTip);
		g_ProfileUI.LockedToolTipFront = nIndex;

	}
}

int64_t ProfileGetGpuTickSync(int64_t nTickCpu, int64_t nTickGpu)
{
    ProfileUI & UI = g_ProfileUI;
	if (UI.nTickReferenceCpu && UI.nTickReferenceGpu)
	{
		int64_t nTicksPerSecondCpu = ProfileTicksPerSecondCpu();
		int64_t nTicksPerSecondGpu = ProfileTicksPerSecondGpu();

		return (int64_t)((nTickCpu - UI.nTickReferenceCpu) * (double(nTicksPerSecondGpu) / double(nTicksPerSecondCpu)) + UI.nTickReferenceGpu);
	}
	else
	{
		return (int64_t)nTickGpu;
	}
}

void ProfileZoomTo(int64_t nTickStart, int64_t nTickEnd, ProfileTokenType eToken)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	bool bGpu = eToken == ProfileTokenTypeGpu;
	int64_t nStartCpu = S.Frames[S.nFrameCurrent].nFrameStartCpu;
	int64_t nStart = bGpu ? ProfileGetGpuTickSync(nStartCpu, S.Frames[S.nFrameCurrent].nFrameStartGpu) : nStartCpu;
	uint64_t nFrequency = bGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu();

	float fToMs = ProfileTickToMsMultiplier(nFrequency);
	UI.fDetailedOffsetTarget = ProfileLogTickDifference(nStart, nTickStart) * fToMs;
	UI.fDetailedRangeTarget = ProfileMax(ProfileLogTickDifference(nTickStart, nTickEnd) * fToMs, 0.01f); // clamp to 10us
}

void ProfileCenter(int64_t nTickCenter)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	int64_t nStart = S.Frames[S.nFrameCurrent].nFrameStartCpu;
	float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu());
	float fCenter = ProfileLogTickDifference(nStart, nTickCenter) * fToMs;
	UI.fDetailedOffsetTarget = UI.fDetailedOffset = fCenter - 0.5f * UI.fDetailedRange;
}

#if PROFILE_DEBUG
uint64_t* g_pProfileDumpStart = 0;
uint64_t* g_pProfileDumpEnd = 0;
void ProfileDebugDumpRange()
{
	Profile& S = *ProfileGet();
	if (g_pProfileDumpStart != g_pProfileDumpEnd)
	{
		uint64_t* pStart = g_pProfileDumpStart;
		uint64_t* pEnd = g_pProfileDumpEnd;
		while (pStart != pEnd)
		{
			uint64_t nTick = ProfileLogGetTick(*pStart);
			uint64_t nToken = ProfileLogTimerIndex(*pStart);
			uint32_t nTimerId = ProfileGetTimerIndex(nToken);

			const char* pTimerName = S.TimerInfo[nTimerId].pName;
			char buffer[256];
			uint64_t type = ProfileLogType(*pStart);

			const char* pBegin = type == P_LOG_LEAVE ? "END" :
				(type == P_LOG_ENTER ? "BEGIN" : "META");
			snprintf(buffer, 255, "DUMP 0x%p: %s :: %" PRIx64 ": %s\n", pStart, pBegin, nTick, pTimerName);
#ifdef _WIN32
			OutputDebugString(buffer);
#else
			printf("%s", buffer);
#endif
			pStart++;
		}

		g_pProfileDumpStart = g_pProfileDumpEnd;
	}
}
#define P_DEBUG_DUP_RANGE() ProfileDebugDumpRange()
#else
#define P_DEBUG_DUP_RANGE() do{} while(0)
#endif

#define PROFILE_HOVER_DIST 0.5f

void ProfileDrawDetailedContextSwitchBars(uint32_t nY, ProfileThreadIdType nThreadId, uint32_t nContextSwitchStart, uint32_t nContextSwitchEnd, int64_t nBaseTicks, uint32_t nBaseY)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	int64_t nTickIn = -1;
	ProfileThreadIdType nThreadBefore = -1;
	float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu());
	float fMsToScreen = UI.nWidth / UI.fDetailedRange;
	float fMouseX = (float)UI.nMouseX;
	float fMouseY = (float)UI.nMouseY;

	int nLineDrawn = -1;

	for (uint32_t j = nContextSwitchStart; j != nContextSwitchEnd; j = (j + 1) % PROFILE_CONTEXT_SWITCH_BUFFER_SIZE)
	{
		ASSERT(j < PROFILE_CONTEXT_SWITCH_BUFFER_SIZE);
		ProfileContextSwitch CS = S.ContextSwitch[j];

		if (nTickIn == -1)
		{
			if (CS.nThreadIn == nThreadId)
			{
				nTickIn = CS.nTicks;
				nThreadBefore = CS.nThreadOut;
			}
		}
		else
		{
			if (CS.nThreadOut == nThreadId)
			{
				int64_t nTickOut = CS.nTicks;
				float fMsStart = fToMs * ProfileLogTickDifference(nBaseTicks, nTickIn);
				float fMsEnd = fToMs * ProfileLogTickDifference(nBaseTicks, nTickOut);
				if (fMsStart <= fMsEnd)
				{
					float fXStart = fMsStart * fMsToScreen;
					float fXEnd = fMsEnd * fMsToScreen;
					float fYStart = (float)nY;
					float fYEnd = fYStart + (PROFILE_DETAILED_CONTEXT_SWITCH_HEIGHT);
					uint32_t nColor = g_nProfileContextSwitchThreadColors[CS.nCpu%PROFILE_NUM_CONTEXT_SWITCH_COLORS];
					float fXDist = ProfileMax(fXStart - fMouseX, fMouseX - fXEnd);
					bool bHover = fXDist < PROFILE_HOVER_DIST && fYStart <= fMouseY && fMouseY <= fYEnd && nBaseY < fMouseY;
					if (bHover)
					{
						UI.nRangeBegin = nTickIn;
						UI.nRangeEnd = nTickOut;
						S.nContextSwitchHoverTickIn = nTickIn;
						S.nContextSwitchHoverTickOut = nTickOut;
						S.nContextSwitchHoverThread = CS.nThreadOut;
						S.nContextSwitchHoverThreadBefore = nThreadBefore;
						S.nContextSwitchHoverThreadAfter = CS.nThreadIn;
						S.nContextSwitchHoverCpuNext = CS.nCpu;
						nColor = UI.nHoverColor;
					}
					if (CS.nCpu == S.nContextSwitchHoverCpu)
					{
						nColor = UI.nHoverColorShared;
					}

					uint32_t nIntegerWidth = (uint32_t)(fXEnd - fXStart);
					if (nIntegerWidth)
					{
						ProfileDrawBox((int)fXStart, (int)fYStart, (int)fXEnd, (int)fYEnd, nColor | UI.nOpacityForeground, ProfileBoxTypeFlat);
					}
					else
					{
						float fXAvg = 0.5f * (fXStart + fXEnd);
						int nLineX = (int)floor(fXAvg + 0.5f);

						if (nLineDrawn != nLineX)
						{
							nLineDrawn = nLineX;
							ProfileDrawLineVertical(nLineX, (int)(fYStart + 0.5f), int(fYEnd + 0.5f), nColor | UI.nOpacityForeground);
						}
					}
				}
				nTickIn = -1;
			}
		}
	}
}

void ProfileWriteThreadHeader(uint32_t nY, ProfileThreadIdType ThreadId, const char* pNamedThread, const char* pThreadModule)
{
	char Buffer[512];
	if (pThreadModule)
	{
		snprintf(Buffer, sizeof(Buffer) - 1, "%04x: %s [%s]", (uint32_t)ThreadId, pNamedThread ? pNamedThread : "", pThreadModule);
	}
	else
	{
		snprintf(Buffer, sizeof(Buffer) - 1, "%04x: %s", (uint32_t)ThreadId, pNamedThread ? pNamedThread : "");
	}
	uint32_t nStrLen = (uint32_t)strlen(Buffer);
	ProfileDrawTextBackground(10, nY, 0xffffff, 0x88777777, Buffer, nStrLen);
}

uint32_t ProfileWriteProcessHeader(uint32_t nY, uint32_t nProcessId)
{
	char Name[256];
	const char* pProcessName = ProfileGetProcessName(nProcessId, Name, sizeof(Name));

	char Buffer[512];
	nY += PROFILE_TEXT_HEIGHT + 1;
	if (pProcessName)
	{
		snprintf(Buffer, sizeof(Buffer) - 1, "* %04x: %s", nProcessId, pProcessName);
	}
	else
	{
		snprintf(Buffer, sizeof(Buffer) - 1, "* %04x", nProcessId);
	}
	uint32_t nStrLen = (uint32_t)strlen(Buffer);
	ProfileDrawTextBackground(0, nY, 0xffffff, 0x88777777, Buffer, nStrLen);
	nY += PROFILE_TEXT_HEIGHT + 1;
	return nY;
}

void ProfileGetFrameRange(int64_t nTicks, int64_t nTicksEnd, int32_t nLogIndex, uint32_t* nFrameBegin, uint32_t* nFrameEnd)
{
	Profile& S = *ProfileGet();
	ASSERT(nLogIndex < 0 || S.Pool[nLogIndex]);

	bool bGpu = (nLogIndex >= 0) ? S.Pool[nLogIndex]->nGpu != 0 : false;
	uint32_t nPut = (nLogIndex >= 0) ? S.Pool[nLogIndex]->nPut.load(std::memory_order_relaxed) : 0;

	uint32_t nBegin = S.nFrameCurrent;

	for (uint32_t i = 0; i < PROFILE_MAX_FRAME_HISTORY - PROFILE_GPU_FRAME_DELAY; ++i)
	{
		uint32_t nFrame = (S.nFrameCurrent + PROFILE_MAX_FRAME_HISTORY - i) % PROFILE_MAX_FRAME_HISTORY;

		if (nLogIndex >= 0)
		{
			uint32_t nCurrStart = S.Frames[nBegin].nLogStart[nLogIndex];
			uint32_t nPrevStart = S.Frames[nFrame].nLogStart[nLogIndex];
			bool bOverflow = (nPrevStart <= nCurrStart) ? (nPut >= nPrevStart && nPut < nCurrStart) : (nPut < nCurrStart || nPut >= nPrevStart);
			if (bOverflow)
				break;
		}

		nBegin = nFrame;
		if ((bGpu ? S.Frames[nBegin].nFrameStartGpu : S.Frames[nBegin].nFrameStartCpu) <= nTicks)
			break;
	}

	uint32_t nEnd = nBegin;

	while (nEnd != S.nFrameCurrent)
	{
		nEnd = (nEnd + 1) % PROFILE_MAX_FRAME_HISTORY;
		if ((bGpu ? S.Frames[nEnd].nFrameStartGpu : S.Frames[nEnd].nFrameStartCpu) >= nTicksEnd)
			break;
	}

	*nFrameBegin = nBegin;
	*nFrameEnd = nEnd;
}
#include <algorithm>
void ProfileDrawDetailedBars(uint32_t nWidth, uint32_t nHeight, int nBaseY, int nSelectedFrame)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	P_DEBUG_DUP_RANGE();
	int nY = nBaseY - UI.nOffsetY[P_DRAW_DETAILED];
	int64_t nNumBoxes = 0;
	int64_t nNumLines = 0;

	UI.nRangeBegin = 0;
	UI.nRangeEnd = 0;
	UI.nRangeBeginGpu = 0;
	UI.nRangeEndGpu = 0;
	UI.nRangeBeginIndex = UI.nRangeEndIndex = 0;
	UI.pRangeLog = 0;

	int64_t nFrameStartCpu = S.Frames[S.nFrameCurrent].nFrameStartCpu;
	int64_t nFrameStartGpu = S.Frames[S.nFrameCurrent].nFrameStartGpu;
	int64_t nTicksPerSecondCpu = ProfileTicksPerSecondCpu();
	int64_t nTicksPerSecondGpu = ProfileTicksPerSecondGpu();
	float fToMsCpu = ProfileTickToMsMultiplier(nTicksPerSecondCpu);
	float fToMsGpu = ProfileTickToMsMultiplier(nTicksPerSecondGpu);

	if (!S.nRunning && UI.nTickReferenceCpu < nFrameStartCpu)
	{
		int64_t nRefCpu = 0, nRefGpu = 0;
		if (ProfileGetGpuTickReference(&nRefCpu, &nRefGpu))
		{
			UI.nTickReferenceCpu = nRefCpu;
			UI.nTickReferenceGpu = nRefGpu;
		}
	}

	float fDetailedOffset = UI.fDetailedOffset;
	float fDetailedRange = UI.fDetailedRange;

	int64_t nDetailedOffsetTicksCpu = ProfileMsToTick(fDetailedOffset, ProfileTicksPerSecondCpu());
	int64_t nDetailedOffsetTicksGpu = ProfileMsToTick(fDetailedOffset, ProfileTicksPerSecondGpu());
	int64_t nBaseTicksCpu = nDetailedOffsetTicksCpu + nFrameStartCpu;
	int64_t nBaseTicksGpu = ProfileGetGpuTickSync(nBaseTicksCpu, nDetailedOffsetTicksGpu + nFrameStartGpu);
	int64_t nBaseTicksEndCpu = nBaseTicksCpu + ProfileMsToTick(fDetailedRange, ProfileTicksPerSecondCpu());
	int64_t nBaseTicksEndGpu = nBaseTicksGpu + ProfileMsToTick(fDetailedRange, ProfileTicksPerSecondGpu());

	uint32_t nFrameBegin, nFrameEnd;
	ProfileGetFrameRange(nBaseTicksCpu, nBaseTicksEndCpu, -1, &nFrameBegin, &nFrameEnd);

	float fMsBase = fToMsCpu * nDetailedOffsetTicksCpu;
	float fMs = fDetailedRange;
	float fMsEnd = fMs + fMsBase;
	float fWidth = (float)nWidth;
	float fMsToScreen = fWidth / fMs;

	for (uint32_t i = nFrameBegin; i != nFrameEnd; i = (i + 1) % PROFILE_MAX_FRAME_HISTORY)
	{
		uint64_t nTickStart = S.Frames[i].nFrameStartCpu;
		float fMsStart = fToMsCpu * ProfileLogTickDifference(nBaseTicksCpu, nTickStart);
		float fXStart = fMsStart * fMsToScreen;

		ProfileDrawLineVertical((int)(fXStart), nBaseY, nBaseY + nHeight, UI.nOpacityForeground | 0xbbbbbb);
	}

	{
		float fRate = floor(2 * (log10(fMs) - 1)) / 2;
		float fStep = powf(10.f, fRate);
		float fRcpStep = 1.f / fStep;
		int nColorIndex = (int)(floor(fMsBase*fRcpStep));
		float fStart = floor(fMsBase*fRcpStep) * fStep;

		char StepLabel[64] = "";
		if (fStep >= 0.005 && fStep <= 1000)
		{
			if (fStep >= 1)
				sprintf(StepLabel, "%.3gms", fStep);
			else
				sprintf(StepLabel, "%.2fms", fStep);
		}

		uint32_t nStepLabelLength = (uint32_t)strlen(StepLabel);
		float fStepLabelOffset = (fStep*fMsToScreen - nStepLabelLength * (PROFILE_TEXT_WIDTH + 1)) / 2;

		for (float f = fStart; f < fMsEnd; )
		{
			float fStart = f;
			float fNext = f + fStep;
			ProfileDrawBox((int)((fStart - fMsBase) * fMsToScreen), nBaseY, (int)((fNext - fMsBase) * fMsToScreen + 1), nBaseY + nHeight, UI.nOpacityBackground | g_nProfileBackColors[nColorIndex++ & 1], ProfileBoxTypeFlat);

			if (nStepLabelLength)
				ProfileDrawText((int)((fStart - fMsBase) * fMsToScreen + fStepLabelOffset), nBaseY, UI.nOpacityForeground | 0x808080, StepLabel, nStepLabelLength);

			f = fNext;
		}
	}

	nY += PROFILE_TEXT_HEIGHT + 1;

	ProfileLogEntry* pMouseOver = UI.pDisplayMouseOver;
	ProfileLogEntry* pMouseOverNext = 0;
	uint64_t nMouseOverToken = pMouseOver ? UI.nDisplayMouseOverTimerIndex : PROFILE_INVALID_TOKEN;

	float fMouseX = (float)UI.nMouseX;
	float fMouseY = (float)UI.nMouseY;
	uint64_t nHoverToken = PROFILE_INVALID_TOKEN;
	int64_t nHoverTime = 0;

	static int nHoverCounter = 155;
	static int nHoverCounterDelta = 10;
	nHoverCounter += nHoverCounterDelta;
	if (nHoverCounter >= 245)
		nHoverCounterDelta = -10;
	else if (nHoverCounter < 100)
		nHoverCounterDelta = 10;
	UI.nHoverColor = (nHoverCounter << 24) | (nHoverCounter << 16) | (nHoverCounter << 8) | nHoverCounter;
	uint32_t nHoverCounterShared = nHoverCounter >> 2;
	UI.nHoverColorShared = (nHoverCounterShared << 24) | (nHoverCounterShared << 16) | (nHoverCounterShared << 8) | nHoverCounterShared;

	uint32_t nLinesDrawn[PROFILE_STACK_MAX] = { 0 };

	S.nContextSwitchHoverThread = S.nContextSwitchHoverThreadAfter = S.nContextSwitchHoverThreadBefore = -1;

	uint32_t nContextSwitchStart = -1;
	uint32_t nContextSwitchEnd = -1;
	S.nContextSwitchHoverCpuNext = 0xff;
	S.nContextSwitchHoverTickIn = -1;
	S.nContextSwitchHoverTickOut = -1;
	if (S.bContextSwitchRunning)
	{
		ProfileContextSwitchSearch(&nContextSwitchStart, &nContextSwitchEnd, nBaseTicksCpu, nBaseTicksEndCpu);
	}

	uint64_t nActiveGroup = S.nAllGroupsWanted ? S.nGroupMask : S.nActiveGroupWanted;

	bool bSkipBarView = S.bContextSwitchRunning && S.bContextSwitchNoBars;

	if (!bSkipBarView)
	{
		for (uint32_t i = 0; i < PROFILE_MAX_THREADS; ++i)
		{
			ProfileThreadLog* pLog = S.Pool[i];
			if (!pLog)
				continue;

			bool bGpu = pLog->nGpu != 0;
			float fToMs = bGpu ? fToMsGpu : fToMsCpu;
			int64_t nBaseTicks = bGpu ? nBaseTicksGpu : nBaseTicksCpu;
			int64_t nBaseTicksEnd = bGpu ? nBaseTicksEndGpu : nBaseTicksEndCpu;
			ProfileThreadIdType nThreadId = pLog->nThreadId;

			int64_t nGapTime = (bGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu()) * PROFILE_GAP_TIME / 1000;

			uint32_t nLogFrameBegin, nLogFrameEnd;
			ProfileGetFrameRange(nBaseTicks - nGapTime, nBaseTicksEnd + nGapTime, i, &nLogFrameBegin, &nLogFrameEnd);

			uint32_t nGet = S.Frames[nLogFrameBegin].nLogStart[i];
			uint32_t nPut = nLogFrameEnd == S.nFrameCurrent ? pLog->nPut.load(std::memory_order_relaxed) : S.Frames[nLogFrameEnd].nLogStart[i];
			if (nPut == nGet)
				continue;

			uint32_t nRange[2][2] = { {0, 0}, {0, 0}, };
			ProfileGetRange(nPut, nGet, nRange);

			uint32_t nMaxStackDepth = 0;

			nY += 3;
			ProfileWriteThreadHeader(nY, nThreadId, &pLog->ThreadName[0], NULL);
			nY += 3;
			nY += PROFILE_TEXT_HEIGHT + 1;

			if (S.bContextSwitchRunning)
			{
				ProfileDrawDetailedContextSwitchBars(nY, pLog->nThreadId, nContextSwitchStart, nContextSwitchEnd, nBaseTicks, nBaseY);
				nY -= PROFILE_DETAILED_BAR_HEIGHT;
				nY += PROFILE_DETAILED_CONTEXT_SWITCH_HEIGHT + 1;
			}

			uint32_t nYDelta = PROFILE_DETAILED_BAR_HEIGHT;
			uint32_t nStack[PROFILE_STACK_MAX];
			uint32_t nStackPos = 0;
			for (uint32_t j = 0; j < 2; ++j)
			{
				uint32_t nStart = nRange[j][0];
				uint32_t nEnd = nRange[j][1];
				for (uint32_t k = nStart; k < nEnd; ++k)
				{
					ProfileLogEntry* pEntry = pLog->Log + k;
					uint64_t nType = ProfileLogType(*pEntry);
					if (P_LOG_ENTER == nType)
					{
						ASSERT(nStackPos < PROFILE_STACK_MAX);
						nStack[nStackPos++] = k;
					}
					else if (P_LOG_META == nType)
					{

					}
					else if (P_LOG_LEAVE == nType)
					{
						if (0 == nStackPos)
						{
							continue;
						}

						ProfileLogEntry* pEntryEnter = pLog->Log + nStack[nStackPos - 1];
						if (ProfileLogTimerIndex(*pEntryEnter) != ProfileLogTimerIndex(*pEntry))
						{
							//uprintf("mismatch %llx %llx\n", pEntryEnter->nToken, pEntry->nToken);
							continue;
						}
						int64_t nTickStart = ProfileLogGetTick(*pEntryEnter);
						int64_t nTickEnd = ProfileLogGetTick(*pEntry);
						uint64_t nTimerIndex = ProfileLogTimerIndex(*pEntry);
						uint32_t nColor = S.TimerInfo[nTimerIndex].nColor;
						if (!(nActiveGroup & (1ull << S.TimerInfo[nTimerIndex].nGroupIndex)))
						{
							nStackPos--;
							continue;
						}
						if (nMouseOverToken == nTimerIndex)
						{
							if (pEntry == pMouseOver)
							{
								nColor = UI.nHoverColor;
								if (bGpu)
								{
									UI.nRangeBeginGpu = *pEntryEnter;
									UI.nRangeEndGpu = *pEntry;
									uint32_t nCpuBegin = (nStack[nStackPos - 1] + 1) % PROFILE_BUFFER_SIZE;
									uint32_t nCpuEnd = (k + 1) % PROFILE_BUFFER_SIZE;
									ProfileLogEntry LogCpuBegin = pLog->Log[nCpuBegin];
									ProfileLogEntry LogCpuEnd = pLog->Log[nCpuEnd];
									if (ProfileLogType(LogCpuBegin) == P_LOG_GPU_EXTRA && ProfileLogType(LogCpuEnd) == P_LOG_GPU_EXTRA)
									{
										UI.nRangeBegin = LogCpuBegin;
										UI.nRangeEnd = LogCpuEnd;
									}
									UI.nRangeBeginIndex = nStack[nStackPos - 1];
									UI.nRangeEndIndex = k;
									UI.pRangeLog = pLog;
								}
								else
								{
									UI.nRangeBegin = *pEntryEnter;
									UI.nRangeEnd = *pEntry;
									UI.nRangeBeginIndex = nStack[nStackPos - 1];
									UI.nRangeEndIndex = k;
									UI.pRangeLog = pLog;

								}
							}
							else
							{
								nColor = UI.nHoverColorShared;
							}
						}

						const char* pName = S.TimerInfo[nTimerIndex].pName;
						uint32_t nNameLen = S.TimerInfo[nTimerIndex].nNameLen;

						if (pName[0] == '$' && pEntryEnter < pEntry)
						{
							ProfileLogEntry e = pEntryEnter[1 + bGpu];
							uint64_t nLogType = ProfileLogType(e);
							if (nLogType == P_LOG_LABEL || nLogType == P_LOG_LABEL_LITERAL)
							{
								const char* pLabel = ProfileGetLabel((uint32_t)nLogType, (uint32_t)ProfileLogGetTick(e));

								if (pLabel)
								{
									pName = pLabel;
									nNameLen = (uint32_t)strlen(pLabel);
								}
							}
						}

						nMaxStackDepth = ProfileMax(nMaxStackDepth, nStackPos);
						float fMsStart = fToMs * ProfileLogTickDifference(nBaseTicks, nTickStart);
						float fMsEnd = fToMs * ProfileLogTickDifference(nBaseTicks, nTickEnd);
						float fXStart = fMsStart * fMsToScreen;
						float fXEnd = fMsEnd * fMsToScreen;
						float fYStart = (float)(nY + nStackPos * nYDelta);
						float fYEnd = fYStart + (PROFILE_DETAILED_BAR_HEIGHT);
						float fXDist = ProfileMax(fXStart - fMouseX, fMouseX - fXEnd);
						bool bHover = fXDist < PROFILE_HOVER_DIST && fYStart <= fMouseY && fMouseY <= fYEnd && nBaseY < fMouseY;
						uint32_t nIntegerWidth = (uint32_t)(fXEnd - fXStart);
						if (nIntegerWidth)
						{
							if (bHover && UI.nActiveMenu == (uint32_t)-1)
							{
								nHoverToken = ProfileLogTimerIndex(*pEntry);
#if PROFILE_DEBUG
								UI.nHoverAddressEnter = (uint64_t)pEntryEnter;
								UI.nHoverAddressLeave = (uint64_t)pEntry;
#endif
								nHoverTime = ProfileLogTickDifference(nTickStart, nTickEnd);
								pMouseOverNext = pEntry;
							}

							ProfileDrawBox((int)fXStart, (int)fYStart, (int)fXEnd, (int)fYEnd, nColor | UI.nOpacityForeground, ProfileBoxTypeBar);
#if PROFILE_DETAILED_BAR_NAMES
							if (nIntegerWidth > 3 * PROFILE_TEXT_WIDTH)
							{
								float fXStartText = ProfileMax(fXStart, 0.f);
								int nTextWidth = (int)(fXEnd - fXStartText);
								int nCharacters = (nTextWidth - PROFILE_TEXT_WIDTH) / (PROFILE_TEXT_WIDTH + 1);
								if (nCharacters > 0)
								{
									ProfileDrawText((int)(fXStartText + 1), (int)(fYStart + 1), -1, pName, ProfileMin<uint32_t>(nNameLen, nCharacters));
								}
							}
#endif
							++nNumBoxes;
						}
						else
						{
							float fXAvg = 0.5f * (fXStart + fXEnd);
							int nLineX = (int)floor(fXAvg + 0.5f);
							if (nLineX != (int)nLinesDrawn[nStackPos])
							{
								if (bHover && UI.nActiveMenu == (uint32_t)-1)
								{
									nHoverToken = (uint32_t)ProfileLogTimerIndex(*pEntry);
									nHoverTime = ProfileLogTickDifference(nTickStart, nTickEnd);
									pMouseOverNext = pEntry;
								}
								nLinesDrawn[nStackPos] = nLineX;
								ProfileDrawLineVertical(nLineX, (int)(fYStart + 0.5f), (int)(fYEnd + 0.5f), nColor | UI.nOpacityForeground);
								++nNumLines;
							}
						}
						nStackPos--;

						if (0 == nStackPos && ProfileLogTickDifference(nTickEnd, nBaseTicksEnd) < 0)
						{
							break;
						}
					}
				}
			}
			nY += nMaxStackDepth * nYDelta + PROFILE_DETAILED_BAR_HEIGHT + 1;
		}
	}
	if (S.bContextSwitchRunning && (S.bContextSwitchAllThreads || S.bContextSwitchNoBars))
	{
		uint32_t nContextSwitchSearchEnd = S.bContextSwitchAllThreads ? nContextSwitchEnd : nContextSwitchStart;

		ProfileThreadInfo Threads[PROFILE_MAX_CONTEXT_SWITCH_THREADS];
		uint32_t nNumThreadsBase = 0;
		uint32_t nNumThreads = ProfileContextSwitchGatherThreads(nContextSwitchStart, nContextSwitchSearchEnd, Threads, &nNumThreadsBase);

		eastl::sort(&Threads[nNumThreadsBase], &Threads[nNumThreads],
					[](const ProfileThreadInfo& l, const ProfileThreadInfo& r)
		{
			return l.nProcessId == r.nProcessId ? l.nThreadId < r.nThreadId : l.nProcessId > r.nProcessId;
		});

		uint32_t nStart = nNumThreadsBase;
		if (S.bContextSwitchNoBars)
			nStart = 0;
		ProfileProcessIdType nLastProcessId = P_GETCURRENTPROCESSID();
		for (uint32_t i = nStart; i < nNumThreads; ++i)
		{
			ProfileThreadInfo tt = Threads[i];
			if (tt.nThreadId)
			{
				if (nLastProcessId != tt.nProcessId)
				{
					nY = ProfileWriteProcessHeader(nY, (uint32_t)tt.nProcessId);
					nLastProcessId = tt.nProcessId;
				}

				ProfileDrawDetailedContextSwitchBars(nY + 2, tt.nThreadId, nContextSwitchStart, nContextSwitchEnd, nBaseTicksCpu, nBaseY);

				ProfileWriteThreadHeader(nY, tt.nThreadId, i < nNumThreadsBase && S.Pool[i] ? &S.Pool[i]->ThreadName[0] : NULL, NULL);
				nY += PROFILE_TEXT_HEIGHT + 1;
			}
		}
	}

	S.nContextSwitchHoverCpu = S.nContextSwitchHoverCpuNext;




	UI.pDisplayMouseOver = pMouseOverNext;
	UI.nDisplayMouseOverTimerIndex = pMouseOverNext ? ProfileLogTimerIndex(*pMouseOverNext) : PROFILE_INVALID_TOKEN;

	if (!S.nRunning)
	{
		if (nHoverToken != PROFILE_INVALID_TOKEN && nHoverTime)
		{
			UI.nHoverToken = nHoverToken;
			UI.nHoverTime = nHoverTime;
		}

		if (nSelectedFrame != -1)
		{
			UI.nRangeBegin = S.Frames[nSelectedFrame].nFrameStartCpu;
			UI.nRangeEnd = S.Frames[(nSelectedFrame + 1) % PROFILE_MAX_FRAME_HISTORY].nFrameStartCpu;
			UI.nRangeBeginGpu = S.Frames[nSelectedFrame].nFrameStartGpu;
			UI.nRangeEndGpu = S.Frames[(nSelectedFrame + 1) % PROFILE_MAX_FRAME_HISTORY].nFrameStartGpu;
		}
		if (UI.nRangeBegin != UI.nRangeEnd)
		{
			float fMsStart = fToMsCpu * ProfileLogTickDifference(nBaseTicksCpu, UI.nRangeBegin);
			float fMsEnd = fToMsCpu * ProfileLogTickDifference(nBaseTicksCpu, UI.nRangeEnd);
			float fXStart = fMsStart * fMsToScreen;
			float fXEnd = fMsEnd * fMsToScreen;
			ProfileDrawBox((int)fXStart, nBaseY, (int)fXEnd, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT, ProfileBoxTypeFlat);
			ProfileDrawLineVertical((int)fXStart, nBaseY, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT | 0x44000000);
			ProfileDrawLineVertical((int)fXEnd, nBaseY, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT | 0x44000000);

			fMsStart += fDetailedOffset;
			fMsEnd += fDetailedOffset;
			char sBuffer[32];
			snprintf(sBuffer, sizeof(sBuffer) - 1, "%.2fms", fMsStart);
			uint32_t nLenStart = (uint32_t)strlen(sBuffer);
			float fStartTextWidth = (float)((1 + PROFILE_TEXT_WIDTH) * nLenStart);
			float fStartTextX = fXStart - fStartTextWidth - 2;
			ProfileDrawBox((int)fStartTextX, nBaseY, (int)(fStartTextX + fStartTextWidth + 2), PROFILE_TEXT_HEIGHT + 2 + nBaseY, 0x33000000, ProfileBoxTypeFlat);
			ProfileDrawText((int)fStartTextX + 1, nBaseY, (uint32_t)-1, sBuffer, nLenStart);
			snprintf(sBuffer, sizeof(sBuffer) - 1, "%.2fms", fMsEnd);
			uint32_t nLenEnd = (uint32_t)strlen(sBuffer);
			ProfileDrawBox((int)(fXEnd + 1), nBaseY, (int)(fXEnd + 1 + (1 + PROFILE_TEXT_WIDTH) * nLenEnd + 3), PROFILE_TEXT_HEIGHT + 2 + nBaseY, 0x33000000, ProfileBoxTypeFlat);
			ProfileDrawText((int)(fXEnd + 2), nBaseY + 1, (uint32_t)-1, sBuffer, nLenEnd);

			if (UI.nMouseRight)
			{
				ProfileZoomTo(UI.nRangeBegin, UI.nRangeEnd, ProfileTokenTypeCpu);
			}
		}

		if (UI.nRangeBeginGpu != UI.nRangeEndGpu)
		{
			float fMsStart = fToMsGpu * ProfileLogTickDifference(nBaseTicksGpu, UI.nRangeBeginGpu);
			float fMsEnd = fToMsGpu * ProfileLogTickDifference(nBaseTicksGpu, UI.nRangeEndGpu);
			float fXStart = fMsStart * fMsToScreen;
			float fXEnd = fMsEnd * fMsToScreen;
			ProfileDrawBox((int)fXStart, nBaseY, (int)fXEnd, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT_GPU, ProfileBoxTypeFlat);
			ProfileDrawLineVertical((int)fXStart, nBaseY, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT_GPU | 0x44000000);
			ProfileDrawLineVertical((int)fXEnd, nBaseY, nHeight, PROFILE_FRAME_COLOR_HIGHTLIGHT_GPU | 0x44000000);

			nBaseY += PROFILE_TEXT_HEIGHT + 1;

			fMsStart += fDetailedOffset;
			fMsEnd += fDetailedOffset;
			char sBuffer[32];
			snprintf(sBuffer, sizeof(sBuffer) - 1, "%.2fms", fMsStart);
			uint32_t nLenStart = (uint32_t)strlen(sBuffer);
			float fStartTextWidth = (float)((1 + PROFILE_TEXT_WIDTH) * nLenStart);
			float fStartTextX = fXStart - fStartTextWidth - 2;
			ProfileDrawBox((int)fStartTextX, nBaseY, (int)(fStartTextX + fStartTextWidth + 2), PROFILE_TEXT_HEIGHT + 2 + nBaseY, 0x33000000, ProfileBoxTypeFlat);
			ProfileDrawText((int)(fStartTextX + 1), nBaseY, (uint32_t)-1, sBuffer, nLenStart);
			snprintf(sBuffer, sizeof(sBuffer) - 1, "%.2fms", fMsEnd);
			uint32_t nLenEnd = (uint32_t)strlen(sBuffer);
			ProfileDrawBox((int)(fXEnd + 1), nBaseY, (int)(fXEnd + 1 + (1 + PROFILE_TEXT_WIDTH) * nLenEnd + 3), PROFILE_TEXT_HEIGHT + 2 + nBaseY, 0x33000000, ProfileBoxTypeFlat);
			ProfileDrawText((int)(fXEnd + 2), nBaseY + 1, (uint32_t)-1, sBuffer, nLenEnd);

			if (UI.nMouseRight)
			{
				ProfileZoomTo(UI.nRangeBeginGpu, UI.nRangeEndGpu, ProfileTokenTypeGpu);
			}
		}
	}
}


void ProfileDrawDetailedFrameHistory(uint32_t nWidth, uint32_t nHeight, uint32_t nBaseY, uint32_t nSelectedFrame)
{
    ProfileUI & UI = g_ProfileUI;
	(void)nHeight;

	Profile& S = *ProfileGet();

	const uint32_t nBarHeight = PROFILE_FRAME_HISTORY_HEIGHT;
	float fBaseX = (float)nWidth;
	float fDx = fBaseX / PROFILE_NUM_FRAMES;

	uint32_t nLastIndex = (S.nFrameCurrent + 1) % PROFILE_MAX_FRAME_HISTORY;
	ProfileDrawBox(nBaseY, nWidth, nBaseY + PROFILE_FRAME_HISTORY_HEIGHT, 0xff000000 | g_nProfileBackColors[0], ProfileBoxTypeFlat);
	float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu()) * S.fRcpReferenceTime;
	float fToMsGpu = ProfileTickToMsMultiplier(ProfileTicksPerSecondGpu()) * S.fRcpReferenceTime;


	ProfileFrameState* pFrameCurrent = &S.Frames[S.nFrameCurrent];
	uint64_t nFrameStartCpu = pFrameCurrent->nFrameStartCpu;
	int64_t nDetailedOffsetTicksCpu = ProfileMsToTick(UI.fDetailedOffset, ProfileTicksPerSecondCpu());
	int64_t nCpuStart = nDetailedOffsetTicksCpu + nFrameStartCpu;
	int64_t nCpuEnd = nCpuStart + ProfileMsToTick(UI.fDetailedRange, ProfileTicksPerSecondCpu());;


	float fSelectionStart = (float)nWidth;
	float fSelectionEnd = 0.f;
	for (uint32_t i = 0; i < PROFILE_NUM_FRAMES; ++i)
	{
		uint32_t nIndex = (S.nFrameCurrent + PROFILE_MAX_FRAME_HISTORY - i) % PROFILE_MAX_FRAME_HISTORY;
		ProfileFrameState* pCurrent = &S.Frames[nIndex];
		ProfileFrameState* pNext = &S.Frames[nLastIndex];

		int64_t nTicks = pNext->nFrameStartCpu - pCurrent->nFrameStartCpu;
		int64_t nTicksGpu = pNext->nFrameStartGpu - pCurrent->nFrameStartGpu;
		float fScale = fToMs * nTicks;
		float fScaleGpu = fToMsGpu * nTicksGpu;
		fScale = fScale > 1.f ? 0.f : 1.f - fScale;
		fScaleGpu = fScaleGpu > 1.f ? 0.f : 1.f - fScaleGpu;
		float fXEnd = fBaseX;
		float fXStart = fBaseX - fDx;
		fBaseX = fXStart;
		uint32_t nColor = PROFILE_FRAME_HISTORY_COLOR_CPU;
		if (nIndex == nSelectedFrame)
			nColor = (uint32_t)-1;
		ProfileDrawBox((int)fXStart, (int)(nBaseY + fScale * nBarHeight), (int)fXEnd, nBaseY + PROFILE_FRAME_HISTORY_HEIGHT, nColor, ProfileBoxTypeBar);
		if (pNext->nFrameStartCpu > nCpuStart)
		{
			fSelectionStart = fXStart;
		}
		if (pCurrent->nFrameStartCpu < nCpuEnd && fSelectionEnd == 0.f)
		{
			fSelectionEnd = fXEnd;
		}
		nLastIndex = nIndex;
	}
	ProfileDrawBox((int)fSelectionStart, nBaseY, (int)fSelectionEnd, nBaseY + PROFILE_FRAME_HISTORY_HEIGHT, PROFILE_FRAME_HISTORY_COLOR_HIGHTLIGHT, ProfileBoxTypeFlat);
}
void ProfileDrawDetailedView(uint32_t nWidth, uint32_t nHeight, bool bDrawBars)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	PROFILE_SCOPEI("ProfileUI", "Detailed View", 0x8888000);
	uint32_t nBaseY = PROFILE_TEXT_HEIGHT + 1;

	int nSelectedFrame = -1;
	if (UI.nMouseY > nBaseY && UI.nMouseY <= nBaseY + PROFILE_FRAME_HISTORY_HEIGHT && UI.nActiveMenu == (uint32_t)-1)
	{

		nSelectedFrame = ((PROFILE_NUM_FRAMES) * (UI.nWidth - UI.nMouseX) / UI.nWidth);
		nSelectedFrame = (S.nFrameCurrent + PROFILE_MAX_FRAME_HISTORY - nSelectedFrame) % PROFILE_MAX_FRAME_HISTORY;
		UI.nHoverFrame = nSelectedFrame;
		if (UI.nMouseRight)
		{
			int64_t nRangeBegin = S.Frames[nSelectedFrame].nFrameStartCpu;
			int64_t nRangeEnd = S.Frames[(nSelectedFrame + 1) % PROFILE_MAX_FRAME_HISTORY].nFrameStartCpu;
			ProfileZoomTo(nRangeBegin, nRangeEnd, ProfileTokenTypeCpu);
		}
		if (UI.nMouseDownLeft)
		{
			uint64_t nFrac = (1024 * (PROFILE_NUM_FRAMES) * (UI.nMouseX) / UI.nWidth) % 1024;
			int64_t nRangeBegin = S.Frames[nSelectedFrame].nFrameStartCpu;
			int64_t nRangeEnd = S.Frames[(nSelectedFrame + 1) % PROFILE_MAX_FRAME_HISTORY].nFrameStartCpu;
			ProfileCenter(nRangeBegin + (nRangeEnd - nRangeBegin) * nFrac / 1024);
		}
	}
	else
	{
		UI.nHoverFrame = -1;
	}

	if (bDrawBars)
	{
		ProfileDrawDetailedBars(nWidth, nHeight, nBaseY + PROFILE_FRAME_HISTORY_HEIGHT, nSelectedFrame);
	}

	ProfileDrawDetailedFrameHistory(nWidth, nHeight, nBaseY, nSelectedFrame);
}
void ProfileDrawTextRight(uint32_t nX, uint32_t nY, uint32_t nColor, const char* pStr, uint32_t nStrLen)
{
	ProfileDrawText(nX - nStrLen * (PROFILE_TEXT_WIDTH + 1), nY, nColor, pStr, nStrLen);
}

void ProfileDrawHeader(int32_t nX, uint32_t nWidth, const char* pName)
{
	if (pName)
	{
		ProfileDrawBox(nX - 8, PROFILE_TEXT_HEIGHT + 2, nX + nWidth + 5, PROFILE_TEXT_HEIGHT + 2 + (PROFILE_TEXT_HEIGHT + 1), 0xff000000 | g_nProfileBackColors[1], ProfileBoxTypeFlat);
		ProfileDrawText(nX, PROFILE_TEXT_HEIGHT + 2, (uint32_t)-1, pName, (uint32_t)strlen(pName));
	}
}

typedef void(*ProfileLoopGroupCallback)(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pData);

void ProfileLoopActiveGroupsDraw(int32_t nX, int32_t nY, ProfileLoopGroupCallback CB, void* pData)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	nY += PROFILE_TEXT_HEIGHT + 2;
	uint64_t nGroup = S.nAllGroupsWanted ? S.nGroupMask : S.nActiveGroupWanted;
	uint32_t nCount = 0;
	for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
	{
		uint64_t nMask = 1ll << j;
		if (nMask & nGroup)
		{
			nY += PROFILE_TEXT_HEIGHT + 1;
			for (uint32_t i = 0; i < S.nTotalTimers; ++i)
			{
				uint64_t nTokenMask = ProfileGetGroupMask(S.TimerInfo[i].nToken);
				if (nTokenMask & nMask)
				{
					if (nY >= 0)
						CB(i, nCount, nX, nY, pData);

					nCount += 2;
					nY += PROFILE_TEXT_HEIGHT + 1;

					if (nY > (int)UI.nHeight)
						return;
				}
			}

		}
	}
}


void ProfileCalcTimers(float* pTimers, float* pAverage, float* pMax, float* pMin, float* pCallAverage, float* pExclusive, float* pAverageExclusive, float* pMaxExclusive, uint64_t nGroup, uint32_t nSize)
{
	Profile& S = *ProfileGet();

	uint32_t nCount = 0;
	uint64_t nMask = 1;

	for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
	{
		if (nMask & nGroup)
		{
			const float fToMs = ProfileTickToMsMultiplier(S.GroupInfo[j].Type == ProfileTokenTypeGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu());
			for (uint32_t i = 0; i < S.nTotalTimers; ++i)
			{
				uint64_t nTokenMask = ProfileGetGroupMask(S.TimerInfo[i].nToken);
				if (nTokenMask & nMask)
				{
					ASSERT(nCount + 2 <= nSize);
					{
						uint32_t nTimer = i;
						uint32_t nIdx = nCount;
						uint32_t nAggregateFrames = S.nAggregateFrames ? S.nAggregateFrames : 1;
						uint32_t nAggregateCount = S.Aggregate[nTimer].nCount ? S.Aggregate[nTimer].nCount : 1;
						float fToPrc = S.fRcpReferenceTime;
						float fMs = fToMs * (S.Frame[nTimer].nTicks);
						float fPrc = ProfileMin(fMs * fToPrc, 1.f);
						float fAverageMs = fToMs * (S.Aggregate[nTimer].nTicks / nAggregateFrames);
						float fAveragePrc = ProfileMin(fAverageMs * fToPrc, 1.f);
						float fMaxMs = fToMs * (S.AggregateMax[nTimer]);
						float fMaxPrc = ProfileMin(fMaxMs * fToPrc, 1.f);
						float fMinMs = fToMs * (S.AggregateMin[nTimer] != uint64_t(-1) ? S.AggregateMin[nTimer] : 0);
						float fMinPrc = ProfileMin(fMinMs * fToPrc, 1.f);
						float fCallAverageMs = fToMs * (S.Aggregate[nTimer].nTicks / nAggregateCount);
						float fCallAveragePrc = ProfileMin(fCallAverageMs * fToPrc, 1.f);
						float fMsExclusive = fToMs * (S.FrameExclusive[nTimer]);
						float fPrcExclusive = ProfileMin(fMsExclusive * fToPrc, 1.f);
						float fAverageMsExclusive = fToMs * (S.AggregateExclusive[nTimer] / nAggregateFrames);
						float fAveragePrcExclusive = ProfileMin(fAverageMsExclusive * fToPrc, 1.f);
						float fMaxMsExclusive = fToMs * (S.AggregateMaxExclusive[nTimer]);
						float fMaxPrcExclusive = ProfileMin(fMaxMsExclusive * fToPrc, 1.f);
						pTimers[nIdx] = fMs;
						pTimers[nIdx + 1] = fPrc;
						pAverage[nIdx] = fAverageMs;
						pAverage[nIdx + 1] = fAveragePrc;
						pMax[nIdx] = fMaxMs;
						pMax[nIdx + 1] = fMaxPrc;
						pMin[nIdx] = fMinMs;
						pMin[nIdx + 1] = fMinPrc;
						pCallAverage[nIdx] = fCallAverageMs;
						pCallAverage[nIdx + 1] = fCallAveragePrc;
						pExclusive[nIdx] = fMsExclusive;
						pExclusive[nIdx + 1] = fPrcExclusive;
						pAverageExclusive[nIdx] = fAverageMsExclusive;
						pAverageExclusive[nIdx + 1] = fAveragePrcExclusive;
						pMaxExclusive[nIdx] = fMaxMsExclusive;
						pMaxExclusive[nIdx + 1] = fMaxPrcExclusive;
					}
					nCount += 2;
				}
			}
		}
		nMask <<= 1ll;
	}
}

#define SBUF_MAX 32

void ProfileDrawBarArrayCallback(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pExtra)
{
    ProfileUI & UI = g_ProfileUI;
	const uint32_t nHeight = PROFILE_TEXT_HEIGHT;
	const uint32_t nTextWidth = 6 * (1 + PROFILE_TEXT_WIDTH);
	const float fWidth = (float)PROFILE_BAR_WIDTH;

	float* pTimers = ((float**)pExtra)[0];
	float* pTimers2 = ((float**)pExtra)[1];
	Profile& S = *ProfileGet();
	char sBuffer[SBUF_MAX];
	if (pTimers2 && pTimers2[nIdx] > 0.1f)
		snprintf(sBuffer, SBUF_MAX - 1, "%5.2f %3.1fx", pTimers[nIdx], pTimers[nIdx] / pTimers2[nIdx]);
	else
		snprintf(sBuffer, SBUF_MAX - 1, "%5.2f", pTimers[nIdx]);
	if (!pTimers2)
		ProfileDrawBox(nX + nTextWidth, nY, (int)(nX + nTextWidth + fWidth * pTimers[nIdx + 1]), nY + nHeight, UI.nOpacityForeground | S.TimerInfo[nTimer].nColor, ProfileBoxTypeBar);
	ProfileDrawText(nX, nY, (uint32_t)-1, sBuffer, (uint32_t)strlen(sBuffer));
}

uint32_t ProfileDrawBarArray(int32_t nX, int32_t nY, float* pTimers, const char* pName, uint32_t nTotalHeight, float* pTimers2 = NULL)
{
    ProfileUI & UI = g_ProfileUI;
	const uint32_t nTextWidth = 6 * (1 + PROFILE_TEXT_WIDTH);
	const uint32_t nWidth = PROFILE_BAR_WIDTH;

	ProfileDrawLineVertical(nX - 5, 0, nTotalHeight + nY, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	float* pTimersArray[2] = { pTimers, pTimers2 };
	ProfileLoopActiveGroupsDraw(nX, nY, &ProfileDrawBarArrayCallback, pTimersArray);
	ProfileDrawHeader(nX, nTextWidth + nWidth, pName);
	return nWidth + 5 + nTextWidth;

}

void ProfileDrawBarCallCountCallback(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pExtra)
{
	(void)nIdx;
	(void)pExtra;

	Profile& S = *ProfileGet();
	char sBuffer[SBUF_MAX];
	snprintf(sBuffer, SBUF_MAX - 1, "%5d", S.Frame[nTimer].nCount);//fix
	uint32_t nLen = (uint32_t)strlen(sBuffer);
	ProfileDrawText(nX, nY, (uint32_t)-1, sBuffer, nLen);
}

uint32_t ProfileDrawBarCallCount(int32_t nX, int32_t nY, const char* pName)
{
	ProfileLoopActiveGroupsDraw(nX, nY, &ProfileDrawBarCallCountCallback, 0);
	const uint32_t nTextWidth = 6 * PROFILE_TEXT_WIDTH;
	ProfileDrawHeader(nX, 5 + nTextWidth, pName);
	return 5 + nTextWidth;
}

struct ProfileMetaAverageArgs
{
	uint64_t* pCounters;
	float fRcpFrames;
};

void ProfileDrawBarMetaAverageCallback(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pExtra)
{
	(void)nIdx;

	ProfileMetaAverageArgs* pArgs = (ProfileMetaAverageArgs*)pExtra;
	uint64_t* pCounters = pArgs->pCounters;
	float fRcpFrames = pArgs->fRcpFrames;
	char sBuffer[SBUF_MAX];
	snprintf(sBuffer, SBUF_MAX - 1, "%5.2f", pCounters[nTimer] * fRcpFrames);
	uint32_t nLen = (uint32_t)strlen(sBuffer);
	ProfileDrawText(nX - nLen * (PROFILE_TEXT_WIDTH + 1), nY, (uint32_t)-1, sBuffer, nLen);
}

uint32_t ProfileDrawBarMetaAverage(int32_t nX, int32_t nY, uint64_t* pCounters, const char* pName, uint32_t nTotalHeight)
{
	if (!pName)
		return 0;
    ProfileUI & UI = g_ProfileUI;
	ProfileDrawLineVertical(nX - 5, 0, nTotalHeight + nY, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	uint32_t nTextWidth = (1 + PROFILE_TEXT_WIDTH) * ProfileMax<uint32_t>(6, (uint32_t)strlen(pName));
	float fRcpFrames = 1.f / (ProfileGet()->nAggregateFrames ? ProfileGet()->nAggregateFrames : 1);
	ProfileMetaAverageArgs Args = { pCounters, fRcpFrames };
	ProfileLoopActiveGroupsDraw(nX + nTextWidth, nY, &ProfileDrawBarMetaAverageCallback, &Args);
	ProfileDrawHeader(nX, 5 + nTextWidth, pName);
	return 5 + nTextWidth;
}



void ProfileDrawBarMetaCountCallback(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pExtra)
{
	(void)nIdx;

	uint64_t* pCounters = (uint64_t*)pExtra;
	char sBuffer[SBUF_MAX];
	int nLen = snprintf(sBuffer, SBUF_MAX - 1, "%5lld", (long long)pCounters[nTimer]);
	nLen = (int)strlen(sBuffer);
	ProfileDrawText(nX - nLen * (PROFILE_TEXT_WIDTH + 1), nY, (uint32_t)-1, sBuffer, nLen);
}

uint32_t ProfileDrawBarMetaCount(int32_t nX, int32_t nY, uint64_t* pCounters, const char* pName, uint32_t nTotalHeight)
{
	if (!pName)
		return 0;

    ProfileUI & UI = g_ProfileUI;
	ProfileDrawLineVertical(nX - 5, 0, nTotalHeight + nY, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	uint32_t nTextWidth = (1 + PROFILE_TEXT_WIDTH) * ProfileMax<uint32_t>(6, (uint32_t)strlen(pName));
	ProfileLoopActiveGroupsDraw(nX + nTextWidth, nY, &ProfileDrawBarMetaCountCallback, pCounters);
	ProfileDrawHeader(nX, 5 + nTextWidth, pName);
	return 5 + nTextWidth;
}

void ProfileDrawBarLegendCallback(uint32_t nTimer, uint32_t nIdx, uint32_t nX, uint32_t nY, void* pExtra)
{
	(void)nIdx;
	(void)pExtra;

    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	if (S.TimerInfo[nTimer].bGraph)
	{
		ProfileDrawText(nX, nY, S.TimerInfo[nTimer].nColor, ">", 1);
	}
	ProfileDrawTextRight(nX, nY, S.TimerInfo[nTimer].nColor, S.TimerInfo[nTimer].pName, (uint32_t)strlen(S.TimerInfo[nTimer].pName));
	if (UI.nMouseY >= nY && UI.nMouseY < nY + PROFILE_TEXT_HEIGHT + 1)
	{
		UI.nHoverToken = nTimer;
		UI.nHoverTime = 0;
	}
}

uint32_t ProfileDrawBarLegend(int32_t nX, int32_t nY, uint32_t nTotalHeight, uint32_t nMaxWidth)
{
    ProfileUI & UI = g_ProfileUI;
	ProfileDrawLineVertical(nX - 5, nY, nTotalHeight, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	ProfileLoopActiveGroupsDraw(nMaxWidth, nY, &ProfileDrawBarLegendCallback, 0);
	return nX;
}

bool ProfileDrawGraph(uint32_t nScreenWidth, uint32_t nScreenHeight)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	PROFILE_SCOPEI("ProfileUI", "Draw Graph", 0xff44ee00);
	bool bEnabled = false;
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
		if (S.Graph[i].nToken != PROFILE_INVALID_TOKEN)
			bEnabled = true;
	if (!bEnabled)
		return false;

	uint32_t nX = nScreenWidth - PROFILE_GRAPH_WIDTH;
	uint32_t nY = nScreenHeight - PROFILE_GRAPH_HEIGHT;
	ProfileDrawBox(nX, nY, nX + PROFILE_GRAPH_WIDTH, nY + PROFILE_GRAPH_HEIGHT, 0x88000000 | g_nProfileBackColors[0], ProfileBoxTypeFlat);
	bool bMouseOver = UI.nMouseX >= nX && UI.nMouseY >= nY;
	float fMouseXPrc = (float(UI.nMouseX - nX)) / PROFILE_GRAPH_WIDTH;
	if (bMouseOver)
	{
		float fXAvg = fMouseXPrc * PROFILE_GRAPH_WIDTH + nX;
		ProfileDrawLineVertical((int)fXAvg, nY, nY + PROFILE_GRAPH_HEIGHT, (uint32_t)-1);
	}


	float fY = (float)nScreenHeight;
	float fDX = PROFILE_GRAPH_WIDTH * 1.f / PROFILE_GRAPH_HISTORY;
	float fDY = PROFILE_GRAPH_HEIGHT;
	uint32_t nPut = S.nGraphPut;
	float* pGraphData = (float*)alloca(sizeof(float)* PROFILE_GRAPH_HISTORY * 2);
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
	{
		if (S.Graph[i].nToken != PROFILE_INVALID_TOKEN)
		{
			uint32_t nGroupId = ProfileGetGroupIndex(S.Graph[i].nToken);
			bool bGpu = S.GroupInfo[nGroupId].Type == ProfileTokenTypeGpu;
			float fToMs = ProfileTickToMsMultiplier(bGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu());
			float fToPrc = fToMs * S.fRcpReferenceTime * 3 / 4;

			float fX = (float)nX;
			for (uint32_t j = 0; j < PROFILE_GRAPH_HISTORY; ++j)
			{
				float fWeigth = ProfileMin(fToPrc * (S.Graph[i].nHistory[(j + nPut) % PROFILE_GRAPH_HISTORY]), 1.f);
				pGraphData[(j * 2)] = fX;
				pGraphData[(j * 2) + 1] = fY - fDY * fWeigth;
				fX += fDX;
			}
			ProfileDrawLine2D(PROFILE_GRAPH_HISTORY, pGraphData, UI.nOpacityForeground | S.TimerInfo[ProfileGetTimerIndex(S.Graph[i].nToken)].nColor);
		}
	}
	{
		float fY1 = 0.25f * PROFILE_GRAPH_HEIGHT + nY;
		float fY2 = 0.50f * PROFILE_GRAPH_HEIGHT + nY;
		float fY3 = 0.75f * PROFILE_GRAPH_HEIGHT + nY;
		ProfileDrawLineHorizontal(nX, nX + PROFILE_GRAPH_WIDTH, (int)fY1, 0xffdd4444);
		ProfileDrawLineHorizontal(nX, nX + PROFILE_GRAPH_WIDTH, (int)fY2, 0xff000000 | g_nProfileBackColors[0]);
		ProfileDrawLineHorizontal(nX, nX + PROFILE_GRAPH_WIDTH, (int)fY3, 0xff000000 | g_nProfileBackColors[0]);

		char buf[32];
		snprintf(buf, sizeof(buf) - 1, "%5.2fms", S.fReferenceTime);
		uint32_t nLen = (uint32_t)strlen(buf);
		ProfileDrawText(nX + 1, (int)(fY1 - (2 + PROFILE_TEXT_HEIGHT)), (uint32_t)-1, buf, nLen);
	}



	if (bMouseOver)
	{
		uint32_t pColors[PROFILE_MAX_GRAPHS];
		ProfileStringArray Strings;
		ProfileStringArrayClear(&Strings);
		uint32_t nTextCount = 0;
		uint32_t nGraphIndex = (S.nGraphPut + PROFILE_GRAPH_HISTORY - int(PROFILE_GRAPH_HISTORY*(1.f - fMouseXPrc))) % PROFILE_GRAPH_HISTORY;

		uint32_t nX = UI.nMouseX;
		uint32_t nY = UI.nMouseY + 20;

		for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
		{
			if (S.Graph[i].nToken != PROFILE_INVALID_TOKEN)
			{
				uint32_t nGroupId = ProfileGetGroupIndex(S.Graph[i].nToken);
				bool bGpu = S.GroupInfo[nGroupId].Type == ProfileTokenTypeGpu;
				float fToMs = ProfileTickToMsMultiplier(bGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu());
				uint32_t nIndex = ProfileGetTimerIndex(S.Graph[i].nToken);
				uint32_t nColor = S.TimerInfo[nIndex].nColor;
				const char* pName = S.TimerInfo[nIndex].pName;
				pColors[nTextCount++] = nColor;
				ProfileStringArrayAddLiteral(&Strings, pName);
				ProfileStringArrayFormat(&Strings, "%5.2fms", fToMs * (S.Graph[i].nHistory[nGraphIndex]));
			}
		}
		if (nTextCount)
		{
			ProfileDrawFloatWindow(nX, nY, Strings.ppStrings, Strings.nNumStrings, 0, pColors);
		}

		if (UI.nMouseRight)
		{
			for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
			{
				S.Graph[i].nToken = PROFILE_INVALID_TOKEN;
			}
		}
	}

	return bMouseOver;
}

void ProfileDumpTimers()
{
	Profile& S = *ProfileGet();

	uint64_t nActiveGroup = S.nGroupMask;

	uint32_t nNumTimers = S.nTotalTimers;
	uint32_t nBlockSize = 2 * nNumTimers;
	float* pTimers = (float*)alloca(nBlockSize * 8 * sizeof(float));
	float* pAverage = pTimers + nBlockSize;
	float* pMax = pTimers + 2 * nBlockSize;
	float* pMin = pTimers + 3 * nBlockSize;
	float* pCallAverage = pTimers + 4 * nBlockSize;
	float* pTimersExclusive = pTimers + 5 * nBlockSize;
	float* pAverageExclusive = pTimers + 6 * nBlockSize;
	float* pMaxExclusive = pTimers + 7 * nBlockSize;
	ProfileCalcTimers(pTimers, pAverage, pMax, pMin, pCallAverage, pTimersExclusive, pAverageExclusive, pMaxExclusive, nActiveGroup, nBlockSize);

	PROFILE_PRINTF("%11s, ", "Time");
	PROFILE_PRINTF("%11s, ", "Average");
	PROFILE_PRINTF("%11s, ", "Max");
	PROFILE_PRINTF("%11s, ", "Min");
	PROFILE_PRINTF("%11s, ", "Call Avg");
	PROFILE_PRINTF("%9s, ", "Count");
	PROFILE_PRINTF("%11s, ", "Excl");
	PROFILE_PRINTF("%11s, ", "Avg Excl");
	PROFILE_PRINTF("%11s, \n", "Max Excl");

	for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
	{
		uint64_t nMask = 1ll << j;
		if (nMask & nActiveGroup)
		{
			PROFILE_PRINTF("%s\n", S.GroupInfo[j].pName);
			for (uint32_t i = 0; i < S.nTotalTimers; ++i)
			{
				uint64_t nTokenMask = ProfileGetGroupMask(S.TimerInfo[i].nToken);
				if (nTokenMask & nMask)
				{
					uint32_t nIdx = i * 2;
					PROFILE_PRINTF("%9.2fms, ", pTimers[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pAverage[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pMax[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pMin[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pCallAverage[nIdx]);
					PROFILE_PRINTF("%9d, ", S.Frame[i].nCount);
					PROFILE_PRINTF("%9.2fms, ", pTimersExclusive[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pAverageExclusive[nIdx]);
					PROFILE_PRINTF("%9.2fms, ", pMaxExclusive[nIdx]);
					PROFILE_PRINTF("%s\n", S.TimerInfo[i].pName);
				}
			}
		}
	}
}



uint32_t ProfileDrawCounterRecursive(uint32_t nIndex, uint32_t nY, uint32_t nOffset, uint32_t nTimerWidth)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	uint8_t bGraphDetailed = 0 != (S.CounterInfo[nIndex].nFlags & PROFILE_COUNTER_FLAG_DETAILED_GRAPH);
	uint32_t nRows = bGraphDetailed ? 5 : 1;
	const uint32_t nHeight = PROFILE_TEXT_HEIGHT;
	const uint32_t nCounterWidth = UI.nCounterWidth;
	const uint32_t nLimitWidth = UI.nLimitWidth;

	uint32_t nY0 = nY + nOffset * (nHeight + 1);
	uint32_t nBackHeight = (nHeight + 1) * nRows;

	ProfileCounterInfo& CI = S.CounterInfo[nIndex];
	bool bInside = (UI.nActiveMenu == (uint32_t)-1) && ((UI.nMouseY >= nY0) && (UI.nMouseY < (nY0 + nBackHeight)));
	uint32_t nTotalWidth = nTimerWidth + nCounterWidth * 3 + PROFILE_COUNTER_WIDTH + nLimitWidth + 4 * (PROFILE_TEXT_WIDTH + 1)
		+ 4 + PROFILE_GRAPH_HISTORY;
	uint32_t nBackColor = 0xff000000 | (g_nProfileBackColors[nOffset & 1] + ((bInside) ? 0x002c2c2c : 0));
	ProfileDrawBox(0, nY0, nTotalWidth, nY0 + nBackHeight + 1, nBackColor, ProfileBoxTypeFlat);
	uint32_t nIndent = PROFILE_COUNTER_INDENT * CI.nLevel * (PROFILE_TEXT_WIDTH + 1);
	if (CI.nFirstChild != -1 && 0 != (CI.nFlags & PROFILE_COUNTER_FLAG_CLOSED))
	{
		ProfileDrawText(nIndent, nY0, 0xffffffff, "*", 1);
	}

	ProfileDrawText(nIndent + PROFILE_TEXT_WIDTH + 1, nY0, 0xffffffff, CI.pName, CI.nNameLen);
	char buffer[64];
	int64_t nCounterValue = S.Counters[nIndex].load();
	uint32_t nX = nTimerWidth + nCounterWidth;
	int nLen = ProfileFormatCounter(S.CounterInfo[nIndex].eFormat, nCounterValue, buffer, sizeof(buffer));
	UI.nCounterWidthTemp = ProfileMax((uint32_t)nLen, UI.nCounterWidthTemp);
	if (0 != nCounterValue || 0 != (CI.nFlags & PROFILE_COUNTER_FLAG_LEAF))
	{
		ProfileDrawTextRight(nX, nY0, 0xffffffff, buffer, nLen);
	}
	int64_t nLimit = S.CounterInfo[nIndex].nLimit;
	if (nLimit)
	{
		nX += PROFILE_TEXT_WIDTH + 1;
		ProfileDrawText(nX, nY0, 0xffffffff, "/", 1);
		nX += 2 * (PROFILE_TEXT_WIDTH + 1);
		int nLen = ProfileFormatCounter(S.CounterInfo[nIndex].eFormat, nLimit, buffer, sizeof(buffer));
		UI.nLimitWidthTemp = ProfileMax(UI.nLimitWidthTemp, (uint32_t)nLen);
		ProfileDrawText(nX, nY0, 0xffffffff, buffer, nLen);
		nX += nLimitWidth;
		nY0 += 1;

		float fCounterPrc = (float)nCounterValue / nLimit;
		fCounterPrc = ProfileMax(fCounterPrc, 0.f);
		float fBoxPrc = 1.f;
		if (fCounterPrc > 1.f)
		{
			fBoxPrc = 1.f / fCounterPrc;
			fCounterPrc = 1.f;
		}

		ProfileDrawBox(nX, nY0, nX + (int)(fBoxPrc * PROFILE_COUNTER_WIDTH), nY0 + nHeight, 0xffffffff, ProfileBoxTypeFlat);
		ProfileDrawBox(nX + 1, nY0 + 1, nX + PROFILE_COUNTER_WIDTH - 1, nY0 + nHeight - 1, nBackColor, ProfileBoxTypeFlat);
		ProfileDrawBox(nX + 1, nY0 + 1, nX + (int)(fCounterPrc * (PROFILE_COUNTER_WIDTH - 1)), nY0 + nHeight - 1, 0xff0088ff, ProfileBoxTypeFlat);
		nX += PROFILE_COUNTER_WIDTH + 5;
	}
	else
	{
		nX += PROFILE_TEXT_WIDTH + 1;
		nX += 2 * (PROFILE_TEXT_WIDTH + 1);
		nX += nLimitWidth;
		nX += PROFILE_COUNTER_WIDTH + 5;
	}

	if (bInside && (UI.nMouseLeft || UI.nMouseRight))
	{
		if (UI.nMouseX > nX)
		{
			if (UI.nMouseRight)
			{
				CI.nFlags &= ~PROFILE_COUNTER_FLAG_DETAILED;
			}
			else
			{
				// toggle through detailed & detailed graph
				if (CI.nFlags & PROFILE_COUNTER_FLAG_DETAILED)
				{
					CI.nFlags ^= PROFILE_COUNTER_FLAG_DETAILED_GRAPH;
				}
				else
				{
					CI.nFlags |= PROFILE_COUNTER_FLAG_DETAILED;
				}
			}
			if (0 == (CI.nFlags & PROFILE_COUNTER_FLAG_DETAILED))
			{
				CI.nFlags &= ~PROFILE_COUNTER_FLAG_DETAILED_GRAPH;
			}
		}
		else if (UI.nMouseLeft)
		{
			CI.nFlags ^= PROFILE_COUNTER_FLAG_CLOSED;
		}
	}

#if PROFILE_COUNTER_HISTORY
	if (0 != (CI.nFlags & PROFILE_COUNTER_FLAG_DETAILED))
	{
		static float pGraphData[PROFILE_GRAPH_HISTORY * 2];
		static float pGraphFillData[PROFILE_GRAPH_HISTORY * 4];

		int32_t nMouseGraph = UI.nMouseX - nX;


		int64_t nCounterMax = S.nCounterMax[nIndex];
		int64_t nCounterMin = S.nCounterMin[nIndex];
		uint32_t nBaseIndex = S.nCounterHistoryPut;
		float fX = (float)nX;

		int64_t nCounterHeightBase = nCounterMax;
		int64_t nCounterOffset = 0;
		if (nCounterMin < 0)
		{
			nCounterHeightBase = nCounterMax - nCounterMin;
			nCounterOffset = -nCounterMin;
		}
		const int32_t nGraphHeight = nRows * nHeight;
		double fRcpMax = nGraphHeight * 1.0 / nCounterHeightBase;
		const int32_t nYOffset = nY0 + (bGraphDetailed ? 3 : 1);
		const int32_t nYBottom = nGraphHeight + nYOffset;
		for (uint32_t i = 0; i < PROFILE_GRAPH_HISTORY; ++i)
		{
			uint32_t nHistoryIndex = (nBaseIndex + i) % PROFILE_GRAPH_HISTORY;
			int64_t nValue = ProfileClamp(S.nCounterHistory[nHistoryIndex][nIndex], nCounterMin, nCounterMax);
			float fPrc = nGraphHeight - (float)((double)(nValue + nCounterOffset) * fRcpMax);
			pGraphData[(i * 2)] = fX;
			pGraphData[(i * 2) + 1] = nYOffset + fPrc;

			pGraphFillData[(i * 4) + 0] = fX;
			pGraphFillData[(i * 4) + 1] = nYOffset + fPrc;
			pGraphFillData[(i * 4) + 2] = fX;
			pGraphFillData[(i * 4) + 3] = (float)nYBottom;

			fX += 1;
		}
		ProfileDrawLine2D(PROFILE_GRAPH_HISTORY * 2, pGraphFillData, 0x330088ff);
		ProfileDrawLine2D(PROFILE_GRAPH_HISTORY, pGraphData, 0xff0088ff);

		if (nMouseGraph < PROFILE_GRAPH_HISTORY && bInside && nCounterMin <= nCounterMax)
		{
			uint32_t nMouseX = nX + nMouseGraph;
			float fMouseX = (float)nMouseX;
			uint32_t nHistoryIndex = (nBaseIndex + nMouseGraph) % PROFILE_GRAPH_HISTORY;
			int64_t nValue = ProfileClamp(S.nCounterHistory[nHistoryIndex][nIndex], nCounterMin, nCounterMax);
			float fPrc = nGraphHeight - (float)((double)(nValue + nCounterOffset) * fRcpMax);
			float fCursor[4];
			fCursor[0] = fMouseX - 2.f;
			fCursor[1] = nYOffset + fPrc + 2.f;
			fCursor[2] = fMouseX + 2.f;
			fCursor[3] = nYOffset + fPrc - 2.f;
			ProfileDrawLine2D(2, fCursor, 0xddff8800);
			fCursor[0] = fMouseX + 2.f;
			fCursor[1] = nYOffset + fPrc + 2.f;
			fCursor[2] = fMouseX - 2.f;
			fCursor[3] = nYOffset + fPrc - 2.f;
			ProfileDrawLine2D(2, fCursor, 0xddff8800);
			int nLen = ProfileFormatCounter(S.CounterInfo[nIndex].eFormat, nValue, buffer, sizeof(buffer));
			ProfileDrawText(nX, nY0, 0xffffffff, buffer, nLen);
		}


		nX += PROFILE_GRAPH_HISTORY + 5;
		if (nCounterMin <= nCounterMax)
		{
			int nLen = ProfileFormatCounter(S.CounterInfo[nIndex].eFormat, nCounterMin, buffer, sizeof(buffer));
			ProfileDrawText(nX, nY0, 0xffffffff, buffer, nLen);
			nX += nCounterWidth;
			nLen = ProfileFormatCounter(S.CounterInfo[nIndex].eFormat, nCounterMax, buffer, sizeof(buffer));
			ProfileDrawText(nX, nY0, 0xffffffff, buffer, nLen);
		}

	}
#endif

	nOffset += nRows;
	if (0 == (CI.nFlags & PROFILE_COUNTER_FLAG_CLOSED))
	{
		int nChild = CI.nFirstChild;
		while (nChild != -1)
		{
			nOffset = ProfileDrawCounterRecursive(nChild, nY, nOffset, nTimerWidth);
			nChild = S.CounterInfo[nChild].nSibling;
		}
	}


	return nOffset;
}

void ProfileDrawCounterView(uint32_t nScreenWidth, uint32_t nScreenHeight)
{
	(void)nScreenWidth;
	(void)nScreenHeight;

    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	PROFILE_SCOPEI("ProfileUI", "DrawCounterView", 0x00dd77);

	UI.nCounterWidthTemp = 7;
	UI.nLimitWidthTemp = 7;
	const uint32_t nHeight = PROFILE_TEXT_HEIGHT;
	uint32_t nTimerWidth = 7 * (PROFILE_TEXT_WIDTH + 1);
	for (uint32_t i = 0; i < S.nNumCounters; ++i)
	{
		uint32_t nWidth = (2 + S.CounterInfo[i].nNameLen + PROFILE_COUNTER_INDENT * S.CounterInfo[i].nLevel) * (PROFILE_TEXT_WIDTH + 1);
		nTimerWidth = ProfileMax(nTimerWidth, nWidth);
	}
	uint32_t nX = nTimerWidth + UI.nOffsetX[P_DRAW_COUNTERS];
	uint32_t nY = nHeight + 3 - UI.nOffsetY[P_DRAW_COUNTERS];
	uint32_t nNumCounters = S.nNumCounters;
	nX = 0;
	nY = (2 * nHeight) + 3 - UI.nOffsetY[P_DRAW_COUNTERS];
	uint32_t nOffset = 0;
	for (uint32_t i = 0; i < nNumCounters; ++i)
	{
		if (S.CounterInfo[i].nParent == -1)
		{
			nOffset = ProfileDrawCounterRecursive(i, nY, nOffset, nTimerWidth);
		}
	}
	nX = 0;
	ProfileDrawHeader(nX, nTimerWidth, "Name");
	nX += nTimerWidth;
	ProfileDrawHeader(nX, UI.nCounterWidth + 1 * (PROFILE_TEXT_WIDTH * 3), "Value");
	nX += UI.nCounterWidth;
	nX += 1 * (PROFILE_TEXT_WIDTH * 3);
	ProfileDrawHeader(nX, UI.nLimitWidth + PROFILE_COUNTER_WIDTH, "Limit");
	nX += UI.nLimitWidth + PROFILE_COUNTER_WIDTH + 4;
	ProfileDrawHeader(nX, PROFILE_GRAPH_HISTORY, "Graph");
	nX += PROFILE_GRAPH_HISTORY + 4;
	ProfileDrawHeader(nX, UI.nCounterWidth, "Min");
	nX += UI.nCounterWidth;
	ProfileDrawHeader(nX, UI.nCounterWidth, "Max");
	nX += UI.nCounterWidth;
	uint32_t nTotalWidth = nX;//nTimerWidth + UI.nCounterWidth + PROFILE_COUNTER_WIDTH + UI.nLimitWidth + 3 * (PROFILE_TEXT_WIDTH+1);



	ProfileDrawLineVertical(nTimerWidth - 2, 0, nOffset*(nHeight + 1) + nY, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	ProfileDrawLineHorizontal(0, nTotalWidth, 2 * PROFILE_TEXT_HEIGHT + 3, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);

	UI.nCounterWidth = (1 + UI.nCounterWidthTemp) * (PROFILE_TEXT_WIDTH + 1);
	UI.nLimitWidth = (1 + UI.nLimitWidthTemp) * (PROFILE_TEXT_WIDTH + 1);

}



void ProfileDrawBarView(uint32_t nScreenWidth, uint32_t nScreenHeight)
{
	(void)nScreenWidth;
	(void)nScreenHeight;

    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	uint64_t nActiveGroup = S.nAllGroupsWanted ? S.nGroupMask : S.nActiveGroupWanted;
	if (!nActiveGroup)
		return;

	PROFILE_SCOPEI("ProfileUI", "DrawBarView", 0x00dd77);

	const uint32_t nHeight = PROFILE_TEXT_HEIGHT;
	int nColorIndex = 0;
	uint32_t nMaxTimerNameLen = 1;
	uint32_t nNumTimers = 0;
	uint32_t nNumGroups = 0;
	for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
	{
		if (nActiveGroup & (1ll << j))
		{
			nNumTimers += S.GroupInfo[j].nNumTimers;
			nNumGroups += 1;
			nMaxTimerNameLen = ProfileMax(nMaxTimerNameLen, S.GroupInfo[j].nMaxTimerNameLen);
		}
	}
	uint32_t nTimerWidth = 2 + (4 + nMaxTimerNameLen) * (PROFILE_TEXT_WIDTH + 1);
	uint32_t nX = nTimerWidth + UI.nOffsetX[P_DRAW_BARS];
	uint32_t nY = nHeight + 3 - UI.nOffsetY[P_DRAW_BARS];
	uint32_t nBlockSize = 2 * nNumTimers;
	float* pTimers = (float*)alloca(nBlockSize * 8 * sizeof(float));
	float* pAverage = pTimers + nBlockSize;
	float* pMax = pTimers + 2 * nBlockSize;
	float* pMin = pTimers + 3 * nBlockSize;
	float* pCallAverage = pTimers + 4 * nBlockSize;
	float* pTimersExclusive = pTimers + 5 * nBlockSize;
	float* pAverageExclusive = pTimers + 6 * nBlockSize;
	float* pMaxExclusive = pTimers + 7 * nBlockSize;
	ProfileCalcTimers(pTimers, pAverage, pMax, pMin, pCallAverage, pTimersExclusive, pAverageExclusive, pMaxExclusive, nActiveGroup, nBlockSize);
	uint32_t nWidth = 0;
	{
		uint32_t nMetaIndex = 0;
		for (uint32_t i = 1; i; i <<= 1)
		{
			if (S.nBars & i)
			{
				if (i >= P_DRAW_META_FIRST)
				{
					if (nMetaIndex < PROFILE_META_MAX && S.MetaCounters[nMetaIndex].pName)
					{
						uint32_t nStrWidth = (uint32_t)strlen(S.MetaCounters[nMetaIndex].pName);
						if (S.nBars & P_DRAW_TIMERS)
							nWidth += 6 + (1 + PROFILE_TEXT_WIDTH) * (nStrWidth);
						if (S.nBars & P_DRAW_AVERAGE)
							nWidth += 6 + (1 + PROFILE_TEXT_WIDTH) * (nStrWidth + 4);
						if (S.nBars & P_DRAW_MAX)
							nWidth += 6 + (1 + PROFILE_TEXT_WIDTH) * (nStrWidth + 4);
						if (S.nBars & P_DRAW_MIN)
							nWidth += 6 + (1 + PROFILE_TEXT_WIDTH) * (nStrWidth + 4);
					}
				}
				else
				{
					nWidth += PROFILE_BAR_WIDTH + 6 + 6 * (1 + PROFILE_TEXT_WIDTH);
					if (i & P_DRAW_CALL_COUNT)
						nWidth += 6 + 6 * PROFILE_TEXT_WIDTH;
				}
			}
			if (i >= P_DRAW_META_FIRST)
			{
				++nMetaIndex;
			}
		}
		nWidth += (1 + nMaxTimerNameLen) * (PROFILE_TEXT_WIDTH + 1);
		for (uint32_t i = 0; i < nNumTimers + nNumGroups + 1; ++i)
		{
			uint32_t nY0 = nY + i * (nHeight + 1);
			bool bInside = (UI.nActiveMenu == (uint32_t)-1) && ((UI.nMouseY >= nY0) && (UI.nMouseY < (nY0 + nHeight + 1)));
			ProfileDrawBox(nX, nY0, nWidth + nX, nY0 + (nHeight + 1) + 1, UI.nOpacityBackground | (g_nProfileBackColors[nColorIndex++ & 1] + ((bInside) ? 0x002c2c2c : 0)), ProfileBoxTypeFlat);
		}
		nX += 10;
	}
	int nTotalHeight = (nNumTimers + nNumGroups + 1) * (nHeight + 1);
	uint32_t nLegendOffset = 1;
	if (S.nBars & P_DRAW_TIMERS)
		nX += ProfileDrawBarArray(nX, nY, pTimers, "Time", nTotalHeight) + 1;
	if (S.nBars & P_DRAW_AVERAGE)
		nX += ProfileDrawBarArray(nX, nY, pAverage, "Average", nTotalHeight) + 1;
	if (S.nBars & P_DRAW_MAX)
		nX += ProfileDrawBarArray(nX, nY, pMax, (!UI.bShowSpikes) ? "Max Time" : "Max Time, Spike", nTotalHeight, UI.bShowSpikes ? pAverage : NULL) + 1;
	if (S.nBars & P_DRAW_MIN)
		nX += ProfileDrawBarArray(nX, nY, pMin, (!UI.bShowSpikes) ? "Min Time" : "Min Time, Spike", nTotalHeight, UI.bShowSpikes ? pAverage : NULL) + 1;
	if (S.nBars & P_DRAW_CALL_COUNT)
	{
		nX += ProfileDrawBarArray(nX, nY, pCallAverage, "Call Average", nTotalHeight) + 1;
		nX += ProfileDrawBarCallCount(nX, nY, "Count") + 1;
	}
	if (S.nBars & P_DRAW_TIMERS_EXCLUSIVE)
		nX += ProfileDrawBarArray(nX, nY, pTimersExclusive, "Exclusive Time", nTotalHeight) + 1;
	if (S.nBars & P_DRAW_AVERAGE_EXCLUSIVE)
		nX += ProfileDrawBarArray(nX, nY, pAverageExclusive, "Exclusive Average", nTotalHeight) + 1;
	if (S.nBars & P_DRAW_MAX_EXCLUSIVE)
		nX += ProfileDrawBarArray(nX, nY, pMaxExclusive, (!UI.bShowSpikes) ? "Exclusive Max Time" : "Excl Max Time, Spike", nTotalHeight, UI.bShowSpikes ? pAverageExclusive : NULL) + 1;

	for (int i = 0; i < PROFILE_META_MAX; ++i)
	{
		if (0 != (S.nBars & (P_DRAW_META_FIRST << i)) && S.MetaCounters[i].pName)
		{
			uint32_t nBufferSize = (uint32_t)strlen(S.MetaCounters[i].pName) + 32;
			char* buffer = (char*)alloca(nBufferSize);
			if (S.nBars & P_DRAW_TIMERS)
				nX += ProfileDrawBarMetaCount(nX, nY, &S.MetaCounters[i].nCounters[0], S.MetaCounters[i].pName, nTotalHeight) + 1;
			if (S.nBars & P_DRAW_AVERAGE)
			{
				snprintf(buffer, nBufferSize - 1, "%s Avg", S.MetaCounters[i].pName);
				nX += ProfileDrawBarMetaAverage(nX, nY, &S.MetaCounters[i].nAggregate[0], buffer, nTotalHeight) + 1;
			}
			if (S.nBars & P_DRAW_MAX)
			{
				snprintf(buffer, nBufferSize - 1, "%s Max", S.MetaCounters[i].pName);
				nX += ProfileDrawBarMetaCount(nX, nY, &S.MetaCounters[i].nAggregateMax[0], buffer, nTotalHeight) + 1;
			}
		}
	}
	nX = 0;
	nY = nHeight + 3 - UI.nOffsetY[P_DRAW_BARS];
	for (uint32_t i = 0; i < nNumTimers + nNumGroups + 1; ++i)
	{
		uint32_t nY0 = nY + i * (nHeight + 1);
		bool bInside = (UI.nActiveMenu == (uint32_t)-1) && ((UI.nMouseY >= nY0) && (UI.nMouseY < (nY0 + nHeight + 1)));
		ProfileDrawBox(nX, nY0, nTimerWidth, nY0 + (nHeight + 1) + 1, 0xff000000 | (g_nProfileBackColors[nColorIndex++ & 1] + ((bInside) ? 0x002c2c2c : 0)), ProfileBoxTypeFlat);
	}
	nX += ProfileDrawBarLegend(nX, nY, nTotalHeight, nTimerWidth - 5) + 1;

	for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
	{
		if (nActiveGroup & (1ll << j))
		{
			ProfileDrawText(nX, nY + (1 + nHeight) * nLegendOffset, (uint32_t)-1, S.GroupInfo[j].pName, S.GroupInfo[j].nNameLen);
			nLegendOffset += S.GroupInfo[j].nNumTimers + 1;
		}
	}
	ProfileDrawHeader(nX, nTimerWidth - 5, "Group");
	ProfileDrawTextRight(nTimerWidth - 3, PROFILE_TEXT_HEIGHT + 2, (uint32_t)-1, "Timer", 5);
	ProfileDrawLineVertical(nTimerWidth, 0, nTotalHeight + nY, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
	ProfileDrawLineHorizontal(0, nWidth, 2 * PROFILE_TEXT_HEIGHT + 3, UI.nOpacityBackground | g_nProfileBackColors[0] | g_nProfileBackColors[1]);
}

typedef const char* (*ProfileSubmenuCallback)(int, bool* bSelected);
typedef void(*ProfileClickCallback)(int);

const char* ProfileUIMenuMode(int nIndex, bool* bSelected)
{
	Profile& S = *ProfileGet();
	switch (nIndex)
	{
	case 0:
		*bSelected = S.nDisplay == P_DRAW_DETAILED;
		return "Detailed";
	case 1:
		*bSelected = S.nDisplay == P_DRAW_BARS;
		return "Timers";
	case 2:
		*bSelected = S.nDisplay == P_DRAW_COUNTERS;
		return "Counters";
	case 3:
		*bSelected = S.nDisplay == P_DRAW_FRAME;
		return "Frame";
	case 4:
		*bSelected = S.nDisplay == P_DRAW_HIDDEN;
		return "Hidden";
	case 5:
		*bSelected = false;
		return "Off";
	case 6:
		*bSelected = false;
		return "------";
	case 7:
		*bSelected = S.nForceEnable != 0;
		return "Force Enable";

	default: return 0;
	}
}


const char* ProfileUIMenuGroups(int nIndex, bool* bSelected)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	*bSelected = false;
	if (nIndex == 0)
	{
		*bSelected = S.nAllGroupsWanted != 0;
		return "[ALL]";
	}
	else
	{
		nIndex = nIndex - 1;
		if (nIndex < (int)UI.GroupMenuCount)
		{
			ProfileGroupMenuItem& Item = UI.GroupMenu[nIndex];
			static char buffer[PROFILE_NAME_MAX_LEN + 32];
			if (Item.nIsCategory)
			{
				uint64_t nGroupMask = S.CategoryInfo[Item.nIndex].nGroupMask;
				*bSelected = nGroupMask == (nGroupMask & S.nActiveGroupWanted);
				snprintf(buffer, sizeof(buffer) - 1, "[%s]", Item.pName);
			}
			else
			{
				*bSelected = 0 != (S.nActiveGroupWanted & (1ll << Item.nIndex));
				snprintf(buffer, sizeof(buffer) - 1, "   %s", Item.pName);
			}
			return buffer;
		}
		return 0;
	}
}

const char* ProfileUIMenuAggregate(int nIndex, bool* bSelected)
{
	Profile& S = *ProfileGet();
	int nNumPresets = (int)sizeof(g_ProfileAggregatePresets) / (int)sizeof(g_ProfileAggregatePresets[0]);
	if (nIndex < nNumPresets)
	{
		int val = g_ProfileAggregatePresets[nIndex];
		*bSelected = (int)S.nAggregateFlip == val;
		if (0 == val)
			return "Infinite";
		else
		{
			static char buf[128];
			snprintf(buf, sizeof(buf) - 1, "%7d", val);
			return buf;
		}
	}
	return 0;

}

const char* ProfileUIMenuTimers(int nIndex, bool* bSelected)
{
	Profile& S = *ProfileGet();

	if (nIndex < 8)
	{
		static const char* kNames[] = { "Time", "Average", "Max", "Min", "Call Count", "Exclusive Timers", "Exclusive Average", "Exclusive Max" };

		*bSelected = 0 != (S.nBars & (1 << nIndex));
		return kNames[nIndex];
	}
	else if (nIndex == 8)
	{
		*bSelected = false;
		return "------";
	}
	else
	{
		int nMetaIndex = nIndex - 9;
		if (nMetaIndex < PROFILE_META_MAX)
		{
			*bSelected = 0 != (S.nBars & (P_DRAW_META_FIRST << nMetaIndex));
			return S.MetaCounters[nMetaIndex].pName;
		}
	}
	return 0;
}

const char* ProfileUIMenuOptions(int nIndex, bool* bSelected)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	if (nIndex >= PROFILE_OPTION_SIZE) return 0;
	switch (UI.Options[nIndex].nSubType)
	{
	case 0:
		*bSelected = S.fReferenceTime == g_ProfileReferenceTimePresets[UI.Options[nIndex].nIndex];
		break;
	case 1:
		*bSelected = UI.nOpacityBackground >> 24 == g_ProfileOpacityPresets[UI.Options[nIndex].nIndex];
		break;
	case 2:
		*bSelected = UI.nOpacityForeground >> 24 == g_ProfileOpacityPresets[UI.Options[nIndex].nIndex];
		break;
	case 3:
		*bSelected = UI.bShowSpikes;
		break;
#if PROFILE_CONTEXT_SWITCH_TRACE
	case 4:
	{
		switch (UI.Options[nIndex].nIndex)
		{
		case 0:
			*bSelected = S.bContextSwitchAllThreads;
			break;
		case 1:
			*bSelected = S.bContextSwitchNoBars;
			break;
		}
	}
	break;
#endif
	}
	return UI.Options[nIndex].Text;
}

const char* ProfileUIMenuPreset(int nIndex, bool* bSelected)
{
	static char buf[128];
	*bSelected = false;
	int nNumPresets = sizeof(g_ProfilePresetNames) / sizeof(g_ProfilePresetNames[0]);
	int nIndexSave = nIndex - nNumPresets - 1;
	if (nIndex == nNumPresets)
		return "--";
	else if (nIndexSave >= 0 && nIndexSave < nNumPresets)
	{
		snprintf(buf, sizeof(buf) - 1, "Save '%s'", g_ProfilePresetNames[nIndexSave]);
		return buf;
	}
	else if (nIndex < nNumPresets)
	{
		snprintf(buf, sizeof(buf) - 1, "Load '%s'", g_ProfilePresetNames[nIndex]);
		return buf;
	}
	else
	{
		return 0;
	}
}

const char* ProfileUIMenuCustom(int nIndex, bool* bSelected)
{
    ProfileUI & UI = g_ProfileUI;
	if ((uint32_t)-1 == UI.nCustomActive)
	{
		*bSelected = nIndex == 0;
	}
	else
	{
		*bSelected = nIndex - 2 == (int)UI.nCustomActive;
	}
	switch (nIndex)
	{
	case 0: return "Disable";
	case 1: return "--";
	default:
		nIndex -= 2;
		if (nIndex < (int)UI.nCustomCount)
		{
			return UI.Custom[nIndex].pName;
		}
		else
		{
			return 0;
		}
	}
}

const char* ProfileUIMenuDump(int nIndex, bool* bSelected)
{
	static char buf[128];
	*bSelected = false;

	if (nIndex < 5)
	{
		snprintf(buf, sizeof(buf) - 1, "%d frames", 32 << nIndex);
		return buf;
	}
	else
	{
		return 0;
	}
}

void ProfileUIClickMode(int nIndex)
{
	Profile& S = *ProfileGet();
	switch (nIndex)
	{
	case 0:
		S.nDisplay = P_DRAW_DETAILED;
		break;
	case 1:
		S.nDisplay = P_DRAW_BARS;
		break;
	case 2:
		S.nDisplay = P_DRAW_COUNTERS;
		break;
	case 3:
		S.nDisplay = P_DRAW_FRAME;
		break;
	case 4:
		S.nDisplay = P_DRAW_HIDDEN;
		break;
	case 5:
		S.nDisplay = 0;
		break;
	case 6:
		break;
	case 7:
		S.nForceEnable = !S.nForceEnable;
		break;
	}
}

void ProfileUIClickGroups(int nIndex)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	if (nIndex == 0)
		S.nAllGroupsWanted = 1 - S.nAllGroupsWanted;
	else
	{
		nIndex -= 1;
		if (nIndex < (int)UI.GroupMenuCount)
		{
			ProfileGroupMenuItem& Item = UI.GroupMenu[nIndex];
			if (Item.nIsCategory)
			{
				uint64_t nGroupMask = S.CategoryInfo[Item.nIndex].nGroupMask;
				if (nGroupMask != (nGroupMask & S.nActiveGroupWanted))
				{
					S.nActiveGroupWanted |= nGroupMask;
				}
				else
				{
					S.nActiveGroupWanted &= ~nGroupMask;
				}
			}
			else
			{
				ASSERT(Item.nIndex < S.nGroupCount);
				S.nActiveGroupWanted ^= (1ll << Item.nIndex);
			}
		}
	}
}

void ProfileUIClickAggregate(int nIndex)
{
	Profile& S = *ProfileGet();
	S.nAggregateFlip = g_ProfileAggregatePresets[nIndex];
	if (0 == S.nAggregateFlip)
	{
		S.nAggregateClear = 1;
	}
}

void ProfileUIClickTimers(int nIndex)
{
	Profile& S = *ProfileGet();

	if (nIndex < 8)
	{
		S.nBars ^= (1 << nIndex);
	}
	else if (nIndex != 8)
	{
		int nMetaIndex = nIndex - 9;
		if (nMetaIndex < PROFILE_META_MAX)
		{
			S.nBars ^= (P_DRAW_META_FIRST << nMetaIndex);
		}
	}
}

void ProfileUIClickOptions(int nIndex)
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	switch (UI.Options[nIndex].nSubType)
	{
	case 0:
		S.fReferenceTime = g_ProfileReferenceTimePresets[UI.Options[nIndex].nIndex];
		S.fRcpReferenceTime = 1.f / S.fReferenceTime;
		break;
	case 1:
		UI.nOpacityBackground = g_ProfileOpacityPresets[UI.Options[nIndex].nIndex] << 24;
		break;
	case 2:
		UI.nOpacityForeground = g_ProfileOpacityPresets[UI.Options[nIndex].nIndex] << 24;
		break;
	case 3:
		UI.bShowSpikes = !UI.bShowSpikes;
		break;
#if PROFILE_CONTEXT_SWITCH_TRACE
	case 4:
	{
		switch (UI.Options[nIndex].nIndex)
		{
		case 0:
			S.bContextSwitchAllThreads = !S.bContextSwitchAllThreads;
			break;
		case 1:
			S.bContextSwitchNoBars = !S.bContextSwitchNoBars;
			break;

		}
	}
	break;
#endif
	}
}

void ProfileUIClickPreset(int nIndex)
{
	int nNumPresets = sizeof(g_ProfilePresetNames) / sizeof(g_ProfilePresetNames[0]);
	int nIndexSave = nIndex - nNumPresets - 1;
	if (nIndexSave >= 0 && nIndexSave < nNumPresets)
	{
		ProfileSavePreset(g_ProfilePresetNames[nIndexSave]);
	}
	else if (nIndex >= 0 && nIndex < nNumPresets)
	{
		ProfileLoadPreset(g_ProfilePresetNames[nIndex]);
	}
}

void ProfileUIClickCustom(int nIndex)
{
	if (nIndex == 0)
	{
		ProfileCustomGroupDisable();
	}
	else
	{
		ProfileCustomGroupEnable(nIndex - 2);
	}
}

void ProfileUIClickDump(int nIndex)
{
	time_t t = time(0);

	char Name[128] = {};
	strftime(Name, sizeof(Name), "microprofile-%Y-%m-%d-%H.%M.%S.html", localtime(&t));

	ProfileDumpFile(Name, ProfileDumpTypeHtml, 32 << nIndex);
}

#include <algorithm>

void ProfileDrawMenu(uint32_t nWidth, uint32_t nHeight)
{
	(void)nWidth;
	(void)nHeight;

    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	uint32_t nX = 0;
	uint32_t nY = 0;
#define SBUF_SIZE 256
	char buffer[256];
	ProfileDrawBox(nX, nY, nX + nWidth, nY + (PROFILE_TEXT_HEIGHT + 1) + 1, 0xff000000 | g_nProfileBackColors[1], ProfileBoxTypeFlat);

#define PROFILE_MENU_MAX 16
	const char* pMenuText[PROFILE_MENU_MAX] = { 0 };
    float nMenuSizes[PROFILE_MENU_MAX] = { 0.0f };
	uint32_t 	nMenuX[PROFILE_MENU_MAX] = { 0 };
	uint32_t nNumMenuItems = 0;

	snprintf(buffer, 127, "Profile");
    // We won't draw Profile in the top left, we will need that space for iOS
#ifndef TARGET_IOS
	uint32_t nLen = (uint32_t)strlen(buffer);
	ProfileDrawText(nX, nY, (uint32_t)-1, buffer, nLen);
	nX += static_cast<uint32_t>(0.055f * nWidth);
#endif
    
    const char * long_menu_items[] = {
        "Mode",
        "Groups",
        "Aggregate[%d]",
        "Timers",
        "Options",
        "Preset",
        "Custom",
        "Dump",
        "Pause",
        "Unpause",
        "Help"
    };
    
    const char * short_menu_items[] = {
        "M",
        "G",
        "A[%d]",
        "T",
        "O",
        "Pr",
        "C",
        "D",
        "P",
        "Unp",
        "H"
    };
    
    const char ** menu_items = nWidth < PROFILE_MIN_WIDTH_TO_DISPLAY_WHOLE_MENU ? short_menu_items : long_menu_items;
    
	// Comment out menus
    nMenuSizes[nNumMenuItems] = 0.053f;
	pMenuText[nNumMenuItems++] = menu_items[0];
    nMenuSizes[nNumMenuItems] = 0.065f;
	pMenuText[nNumMenuItems++] = menu_items[1];
	char AggregateText[64];
	snprintf(AggregateText, sizeof(AggregateText)-1, menu_items[2], S.nAggregateFlip ? S.nAggregateFlip : S.nAggregateFlipCount);
    nMenuSizes[nNumMenuItems] = 0.13f;
	pMenuText[nNumMenuItems++] = &AggregateText[0];
    nMenuSizes[nNumMenuItems] = 0.065f;
	pMenuText[nNumMenuItems++] = menu_items[3];
    nMenuSizes[nNumMenuItems] = 0.07f;
	pMenuText[nNumMenuItems++] = menu_items[4];
    nMenuSizes[nNumMenuItems] = 0.06f;
	pMenuText[nNumMenuItems++] = menu_items[5];
    nMenuSizes[nNumMenuItems] = 0.07f;
	pMenuText[nNumMenuItems++] = menu_items[6];
    nMenuSizes[nNumMenuItems] = 0.055f;
	pMenuText[nNumMenuItems++] = menu_items[7];
	const int nPauseIndex = nNumMenuItems;
    nMenuSizes[nNumMenuItems] = 0.075f;
	pMenuText[nNumMenuItems++] = S.nRunning ? menu_items[8] : menu_items[9];
    nMenuSizes[nNumMenuItems] = 0.043f;
	pMenuText[nNumMenuItems++] = menu_items[10];

	if (S.nOverflow)
	{
		pMenuText[nNumMenuItems++] = "!BUFFERSFULL!";
	}


	if (UI.GroupMenuCount != S.nGroupCount + S.nCategoryCount)
	{
		UI.GroupMenuCount = S.nGroupCount + S.nCategoryCount;
		for (uint32_t i = 0; i < S.nCategoryCount; ++i)
		{
			UI.GroupMenu[i].nIsCategory = 1;
			UI.GroupMenu[i].nCategoryIndex = i;
			UI.GroupMenu[i].nIndex = i;
			UI.GroupMenu[i].pName = S.CategoryInfo[i].pName;
		}
		for (uint32_t i = 0; i < S.nGroupCount; ++i)
		{
			uint32_t idx = i + S.nCategoryCount;
			UI.GroupMenu[idx].nIsCategory = 0;
			UI.GroupMenu[idx].nCategoryIndex = S.GroupInfo[i].nCategory;
			UI.GroupMenu[idx].nIndex = i;
			UI.GroupMenu[idx].pName = S.GroupInfo[i].pName;
		}
		eastl::sort(&UI.GroupMenu[0], &UI.GroupMenu[UI.GroupMenuCount],
			[] (const ProfileGroupMenuItem& l, const ProfileGroupMenuItem& r) -> bool
			{
				if(l.nCategoryIndex < r.nCategoryIndex)
				{
					return true;
				}
				else if(r.nCategoryIndex < l.nCategoryIndex)
				{
					return false;
				}
				if(r.nIsCategory || l.nIsCategory)
				{
					return l.nIsCategory > r.nIsCategory;
				}
				return P_STRCASECMP(l.pName, r.pName)<0;
			}
		);
	}

	ProfileSubmenuCallback GroupCallback[PROFILE_MENU_MAX] =
	{
		&ProfileUIMenuMode,
		&ProfileUIMenuGroups,
		&ProfileUIMenuAggregate,
		&ProfileUIMenuTimers,
		&ProfileUIMenuOptions,
		&ProfileUIMenuPreset,
		&ProfileUIMenuCustom,
		&ProfileUIMenuDump,
	};

	ProfileClickCallback CBClick[PROFILE_MENU_MAX] =
	{
		&ProfileUIClickMode,
		&ProfileUIClickGroups,
		&ProfileUIClickAggregate,
		&ProfileUIClickTimers,
		&ProfileUIClickOptions,
		&ProfileUIClickPreset,
		&ProfileUIClickCustom,
		&ProfileUIClickDump,
	};


	uint32_t nSelectMenu = (uint32_t)-1;
	for (uint32_t i = 0; i < nNumMenuItems; ++i)
	{
		nMenuX[i] = nX;
		uint32_t nEnd = nX + static_cast<uint32_t>(nMenuSizes[i] * nWidth);
		if (UI.nMouseY <= PROFILE_TEXT_HEIGHT && UI.nMouseX <= nEnd && UI.nMouseX >= nX)
		{
			ProfileDrawBox(nX - 1, nY, nEnd, nY + (PROFILE_TEXT_HEIGHT + 1) + 1, 0xff888888, ProfileBoxTypeFlat);
			nSelectMenu = i;
			if ((UI.nMouseLeft || UI.nMouseRight) && (int)i == nPauseIndex)
			{
				S.nToggleRunning = 1;
			}
		}
		ProfileDrawText(nX, nY, (uint32_t)-1, pMenuText[i], (uint32_t)strlen(pMenuText[i]));
		nX += static_cast<uint32_t>(nMenuSizes[i] * nWidth);
	}
	uint32_t nMenu = nSelectMenu != (uint32_t)-1 ? nSelectMenu : UI.nActiveMenu;
	UI.nActiveMenu = nSelectMenu;
	if ((uint32_t)-1 != nMenu && GroupCallback[nMenu])
	{
		nX = nMenuX[nMenu];
		nY += PROFILE_TEXT_HEIGHT + 1;
		ProfileSubmenuCallback CB = GroupCallback[nMenu];
		int nNumLines = 0;
		bool bSelected = false;
		const char* pString = CB(nNumLines, &bSelected);
		uint32_t nWidth = 0, nHeight = 0;
		while (pString)
		{
			nWidth = ProfileMax<int>(nWidth, (int)strlen(pString));
			nNumLines++;
			pString = CB(nNumLines, &bSelected);
		}
		nWidth = (2 + nWidth) * (PROFILE_TEXT_WIDTH + 1);
		nHeight = nNumLines * (PROFILE_TEXT_HEIGHT + 1);
		if (UI.nMouseY <= nY + nHeight + 0 && UI.nMouseY >= nY - 0 && UI.nMouseX <= nX + nWidth + 0 && UI.nMouseX >= nX - 0)
		{
			UI.nActiveMenu = nMenu;
		}
		ProfileDrawBox(nX, nY, nX + nWidth, nY + nHeight, 0xff000000 | g_nProfileBackColors[1], ProfileBoxTypeFlat);
		for (int i = 0; i < nNumLines; ++i)
		{
			bool bSelected = false;
			const char* pString = CB(i, &bSelected);
			if (UI.nMouseY >= nY && UI.nMouseY < nY + PROFILE_TEXT_HEIGHT + 1)
			{
				if ((UI.nMouseLeft || UI.nMouseRight) && CBClick[nMenu])
				{
					CBClick[nMenu](i);
				}
				ProfileDrawBox(nX, nY, nX + nWidth, nY + PROFILE_TEXT_HEIGHT + 1, 0xff888888, ProfileBoxTypeFlat);
			}
			snprintf(buffer, SBUF_SIZE - 1, "%c %s", bSelected ? '*' : ' ', pString);
			uint32_t nLen = (uint32_t)strlen(buffer);
			ProfileDrawText(nX, nY, (uint32_t)-1, buffer, nLen);
			nY += PROFILE_TEXT_HEIGHT + 1;
		}
	}

    
    if(nWidth >= PROFILE_MIN_WIDTH_TO_DISPLAY_WHOLE_MENU)
	{
		static char FrameTimeMessage[64];
		float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu());
		uint32_t nAggregateFrames = S.nAggregateFrames ? S.nAggregateFrames : 1;
		float fMs = fToMs * (S.nFlipTicks);
		float fAverageMs = fToMs * (S.nFlipAggregateDisplay / nAggregateFrames);
		float fMaxMs = fToMs * S.nFlipMaxDisplay;
		snprintf(FrameTimeMessage, sizeof(FrameTimeMessage) - 1, "Time[%6.2f] Avg[%6.2f] Max[%6.2f]", fMs, fAverageMs, fMaxMs);
		uint32_t nLen = (uint32_t)strlen(FrameTimeMessage);
		pMenuText[nNumMenuItems++] = &FrameTimeMessage[0];
		ProfileDrawText(nWidth - static_cast<uint32_t>(205 * getDpiScale().x), 0, -1, FrameTimeMessage, nLen);
	}
}

static int g_PrevX = 0;
static int g_PrevY = 0;

void ProfileSetPreviousMousePosition(uint32_t x, uint32_t y)
{
    g_PrevX = x;
    g_PrevY = y;
}

void ProfileMoveGraph()
{

    ProfileUI & UI = g_ProfileUI;
	int nZoom = UI.nMouseWheelDelta;
	int nPanX = 0;
	int nPanY = 0;
	if (UI.nMouseDownLeft && !UI.nModDown)
	{
		nPanX = UI.nMouseX - g_PrevX;
		nPanY = UI.nMouseY - g_PrevY;
	}
	g_PrevX = UI.nMouseX;
	g_PrevY = UI.nMouseY;

	if (nZoom)
	{
		float fOldRange = UI.fDetailedRange;
		if (nZoom > 0)
		{
			UI.fDetailedRangeTarget = UI.fDetailedRange *= UI.nModDown ? 1.40f : 1.05f;
		}
		else
		{
			float fNewDetailedRange = UI.fDetailedRange / (UI.nModDown ? 1.40f : 1.05f);
			if (fNewDetailedRange < 1e-4f) //100ns
				fNewDetailedRange = 1e-4f;
			UI.fDetailedRangeTarget = UI.fDetailedRange = fNewDetailedRange;
		}

		float fDiff = fOldRange - UI.fDetailedRange;
		float fMousePrc = ProfileMax((float)UI.nMouseX / UI.nWidth, 0.f);
		UI.fDetailedOffsetTarget = UI.fDetailedOffset += fDiff * fMousePrc;

	}
	if (nPanX)
	{
		UI.fDetailedOffsetTarget = UI.fDetailedOffset += -nPanX * UI.fDetailedRange / UI.nWidth;
	}
	int nMode = ProfileGet()->nDisplay;
	if (nMode < P_DRAW_SIZE)
	{
		UI.nOffsetY[nMode] -= nPanY;
		UI.nOffsetX[nMode] += nPanX;
		if (UI.nOffsetX[nMode] > 0)
			UI.nOffsetX[nMode] = 0;
		if (UI.nOffsetY[nMode] < 0)
			UI.nOffsetY[nMode] = 0;
	}
}


void ProfileDrawCustom(uint32_t nWidth, uint32_t nHeight)
{
	(void)nWidth;

    ProfileUI & UI = g_ProfileUI;
	if ((uint32_t)-1 != UI.nCustomActive)
	{
		Profile& S = *ProfileGet();
		ASSERT(UI.nCustomActive < PROFILE_CUSTOM_MAX);
		ProfileCustom* pCustom = &UI.Custom[UI.nCustomActive];
		uint32_t nCount = pCustom->nNumTimers;
		uint32_t nAggregateFrames = S.nAggregateFrames ? S.nAggregateFrames : 1;
		uint32_t nExtraOffset = 1 + ((pCustom->nFlags & PROFILE_CUSTOM_STACK) != 0 ? 3 : 0);
		uint32_t nOffsetYBase = nHeight - (nExtraOffset + nCount)* (1 + PROFILE_TEXT_HEIGHT) - PROFILE_CUSTOM_PADDING;
		uint32_t nOffsetY = nOffsetYBase;
		float fReference = pCustom->fReference;
		float fRcpReference = 1.f / fReference;
		uint32_t nReducedWidth = UI.nWidth - 2 * PROFILE_CUSTOM_PADDING - PROFILE_GRAPH_WIDTH;

		char Buffer[PROFILE_NAME_MAX_LEN * 2 + 1];
		float* pTime = (float*)alloca(sizeof(float)*nCount);
		float* pTimeAvg = (float*)alloca(sizeof(float)*nCount);
		float* pTimeMax = (float*)alloca(sizeof(float)*nCount);
		uint32_t* pColors = (uint32_t*)alloca(sizeof(uint32_t)*nCount);
		uint32_t nMaxOffsetX = 0;
		ProfileDrawBox(PROFILE_CUSTOM_PADDING - 1, nOffsetY - 1, PROFILE_CUSTOM_PADDING + nReducedWidth + 1, UI.nHeight - PROFILE_CUSTOM_PADDING + 1, 0x88000000 | g_nProfileBackColors[0], ProfileBoxTypeFlat);

		for (uint32_t i = 0; i < nCount; ++i)
		{
			uint16_t nTimerIndex = ProfileGetTimerIndex(pCustom->pTimers[i]);
			uint16_t nGroupIndex = ProfileGetGroupIndex(pCustom->pTimers[i]);
			float fToMs = ProfileTickToMsMultiplier(S.GroupInfo[nGroupIndex].Type == ProfileTokenTypeGpu ? ProfileTicksPerSecondGpu() : ProfileTicksPerSecondCpu());
			pTime[i] = S.Frame[nTimerIndex].nTicks * fToMs;
			pTimeAvg[i] = fToMs * (S.Aggregate[nTimerIndex].nTicks / nAggregateFrames);
			pTimeMax[i] = fToMs * (S.AggregateMax[nTimerIndex]);
			pColors[i] = S.TimerInfo[nTimerIndex].nColor;
		}

		ProfileDrawText(PROFILE_CUSTOM_PADDING + 3 * PROFILE_TEXT_WIDTH, nOffsetY, (uint32_t)-1, "Avg", sizeof("Avg") - 1);
		ProfileDrawText(PROFILE_CUSTOM_PADDING + 13 * PROFILE_TEXT_WIDTH, nOffsetY, (uint32_t)-1, "Max", sizeof("Max") - 1);
		for (uint32_t i = 0; i < nCount; ++i)
		{
			nOffsetY += (1 + PROFILE_TEXT_HEIGHT);
			uint16_t nTimerIndex = ProfileGetTimerIndex(pCustom->pTimers[i]);
			uint16_t nGroupIndex = ProfileGetGroupIndex(pCustom->pTimers[i]);
			ProfileTimerInfo* pTimerInfo = &S.TimerInfo[nTimerIndex];
			uint32_t nOffsetX = PROFILE_CUSTOM_PADDING;
			snprintf(Buffer, sizeof(Buffer) - 1, "%6.2f", pTimeAvg[i]);
			uint32_t nSize = (uint32_t)strlen(Buffer);
			ProfileDrawText(nOffsetX, nOffsetY, (uint32_t)-1, Buffer, nSize);
			nOffsetX += (nSize + 2) * (PROFILE_TEXT_WIDTH + 1);
			snprintf(Buffer, sizeof(Buffer) - 1, "%6.2f", pTimeMax[i]);
			nSize = (uint32_t)strlen(Buffer);
			ProfileDrawText(nOffsetX, nOffsetY, (uint32_t)-1, Buffer, nSize);
			nOffsetX += (nSize + 2) * (PROFILE_TEXT_WIDTH + 1);
			snprintf(Buffer, sizeof(Buffer) - 1, "%s:%s", S.GroupInfo[nGroupIndex].pName, pTimerInfo->pName);
			nSize = (uint32_t)strlen(Buffer);
			ProfileDrawText(nOffsetX, nOffsetY, pTimerInfo->nColor, Buffer, nSize);
			nOffsetX += (nSize + 2) * (PROFILE_TEXT_WIDTH + 1);
			nMaxOffsetX = ProfileMax(nMaxOffsetX, nOffsetX);
		}
		uint32_t nMaxWidth = nReducedWidth - nMaxOffsetX;

		if (pCustom->nFlags & PROFILE_CUSTOM_BARS)
		{
			nOffsetY = nOffsetYBase;
			float* pMs = pCustom->nFlags & PROFILE_CUSTOM_BAR_SOURCE_MAX ? pTimeMax : pTimeAvg;
			const char* pString = pCustom->nFlags & PROFILE_CUSTOM_BAR_SOURCE_MAX ? "Max" : "Avg";
			ProfileDrawText(nMaxOffsetX, nOffsetY, (uint32_t)-1, pString, (uint32_t)strlen(pString));
			snprintf(Buffer, sizeof(Buffer) - 1, "%6.2fms", fReference);
			uint32_t nSize = (uint32_t)strlen(Buffer);
			ProfileDrawText(nReducedWidth - (1 + nSize) * (PROFILE_TEXT_WIDTH + 1), nOffsetY, (uint32_t)-1, Buffer, nSize);
			for (uint32_t i = 0; i < nCount; ++i)
			{
				nOffsetY += (1 + PROFILE_TEXT_HEIGHT);
				uint32_t nWidth = ProfileMin(nMaxWidth, (uint32_t)(nMaxWidth * pMs[i] * fRcpReference));
				ProfileDrawBox(nMaxOffsetX, nOffsetY, nMaxOffsetX + nWidth, nOffsetY + PROFILE_TEXT_HEIGHT, pColors[i] | 0xff000000, ProfileBoxTypeFlat);
			}
		}
		if (pCustom->nFlags & PROFILE_CUSTOM_STACK)
		{
			nOffsetY += 2 * (1 + PROFILE_TEXT_HEIGHT);
			const char* pString = pCustom->nFlags & PROFILE_CUSTOM_STACK_SOURCE_MAX ? "Max" : "Avg";
			ProfileDrawText(PROFILE_CUSTOM_PADDING, nOffsetY, (uint32_t)-1, pString, (uint32_t)strlen(pString));
			snprintf(Buffer, sizeof(Buffer) - 1, "%6.2fms", fReference);
			uint32_t nSize = (uint32_t)strlen(Buffer);
			ProfileDrawText(nReducedWidth - (1 + nSize) * (PROFILE_TEXT_WIDTH + 1), nOffsetY, (uint32_t)-1, Buffer, nSize);
			nOffsetY += (1 + PROFILE_TEXT_HEIGHT);
			float fPosX = PROFILE_CUSTOM_PADDING;
			float* pMs = pCustom->nFlags & PROFILE_CUSTOM_STACK_SOURCE_MAX ? pTimeMax : pTimeAvg;
			for (uint32_t i = 0; i < nCount; ++i)
			{
				float fWidth = pMs[i] * fRcpReference * nReducedWidth;
				uint32_t nX = (uint32_t)fPosX;
				fPosX += fWidth;
				uint32_t nXEnd = (uint32_t)fPosX;
				if (nX < nXEnd)
				{
					ProfileDrawBox(nX, nOffsetY, nXEnd, nOffsetY + PROFILE_TEXT_HEIGHT, pColors[i] | 0xff000000, ProfileBoxTypeFlat);
				}
			}
		}
	}
}


extern uint2 ProfileGetDrawDimensions();
extern void ProfileBeginDraw();
extern void ProfileEndDraw(Cmd * pCmd);

void ProfileDraw(Cmd* pCmd)
{
	PROFILE_SCOPEI("ProfileUI", "Draw", 0x737373);
	ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();

	uint32_t nWidth = ProfileGetDrawDimensions().x;
	uint32_t nHeight = ProfileGetDrawDimensions().y;

	// Start our own drawing
	ProfileBeginDraw();

	if (S.nDisplay)
	{
		std::recursive_mutex& m = ProfileGetMutex();
		m.lock();
		UI.nWidth = nWidth;
		UI.nHeight = nHeight;
		UI.nHoverToken = PROFILE_INVALID_TOKEN;
		UI.nHoverTime = 0;
		UI.nHoverFrame = -1;
		if (S.nDisplay != P_DRAW_DETAILED)
			S.nContextSwitchHoverThread = S.nContextSwitchHoverThreadAfter = S.nContextSwitchHoverThreadBefore = -1;
		ProfileMoveGraph();


		if (S.nDisplay == P_DRAW_DETAILED || S.nDisplay == P_DRAW_FRAME)
		{
			ProfileDrawDetailedView(nWidth, nHeight, /* bDrawBars= */ S.nDisplay == P_DRAW_DETAILED);
		}
		else if (S.nDisplay == P_DRAW_BARS && S.nBars)
		{
			ProfileDrawBarView(nWidth, nHeight);
		}
		else if (S.nDisplay == P_DRAW_COUNTERS)
		{
			ProfileDrawCounterView(nWidth, nHeight);
		}

		ProfileDrawMenu(nWidth, nHeight);
		bool bMouseOverGraph = ProfileDrawGraph(nWidth, nHeight);
		ProfileDrawCustom(nWidth, nHeight);
		bool bHidden = S.nDisplay == P_DRAW_HIDDEN;
		if (!bHidden)
		{
			uint32_t nLockedToolTipX = 3;
			bool bDeleted = false;
			for (int i = 0; i < PROFILE_TOOLTIP_MAX_LOCKED; ++i)
			{
				int nIndex = (g_ProfileUI.LockedToolTipFront + i) % PROFILE_TOOLTIP_MAX_LOCKED;
				if (g_ProfileUI.LockedToolTips[nIndex].ppStrings[0])
				{
					uint32_t nToolTipWidth = 0, nToolTipHeight = 0;
					ProfileFloatWindowSize(g_ProfileUI.LockedToolTips[nIndex].ppStrings, g_ProfileUI.LockedToolTips[nIndex].nNumStrings, 0, nToolTipWidth, nToolTipHeight, 0);
					uint32_t nStartY = nHeight - nToolTipHeight - 2;
					if (!bDeleted && UI.nMouseY > nStartY && UI.nMouseX > nLockedToolTipX && UI.nMouseX <= nLockedToolTipX + nToolTipWidth && (UI.nMouseLeft || UI.nMouseRight))
					{
						bDeleted = true;
						int j = i;
						for (; j < PROFILE_TOOLTIP_MAX_LOCKED - 1; ++j)
						{
							int nIndex0 = (g_ProfileUI.LockedToolTipFront + j) % PROFILE_TOOLTIP_MAX_LOCKED;
							int nIndex1 = (g_ProfileUI.LockedToolTipFront + j + 1) % PROFILE_TOOLTIP_MAX_LOCKED;
							ProfileStringArrayCopy(&g_ProfileUI.LockedToolTips[nIndex0], &g_ProfileUI.LockedToolTips[nIndex1]);
						}
						ProfileStringArrayClear(&g_ProfileUI.LockedToolTips[(g_ProfileUI.LockedToolTipFront + j) % PROFILE_TOOLTIP_MAX_LOCKED]);
					}
					else
					{
						ProfileDrawFloatWindow(nLockedToolTipX, nHeight - nToolTipHeight - 2, &g_ProfileUI.LockedToolTips[nIndex].ppStrings[0], g_ProfileUI.LockedToolTips[nIndex].nNumStrings, g_ProfileUI.nLockedToolTipColor[nIndex]);
						nLockedToolTipX += nToolTipWidth + 4;
					}
				}
			}

			if (UI.nActiveMenu == 9)
			{
				if (S.nDisplay & P_DRAW_DETAILED)
				{
					ProfileStringArray DetailedHelp;
					ProfileStringArrayClear(&DetailedHelp);
					ProfileStringArrayFormat(&DetailedHelp, "%s", PROFILE_HELP_RIGHT);
					ProfileStringArrayAddLiteral(&DetailedHelp, "Toggle Graph");
					ProfileStringArrayFormat(&DetailedHelp, "%s", PROFILE_HELP_LEFT);
					ProfileStringArrayAddLiteral(&DetailedHelp, "Zoom");
					ProfileStringArrayFormat(&DetailedHelp, "%s + %s", PROFILE_HELP_MOD, PROFILE_HELP_RIGHT);
					ProfileStringArrayAddLiteral(&DetailedHelp, "Lock Tooltip");
					ProfileStringArrayAddLiteral(&DetailedHelp, "Drag");
					ProfileStringArrayAddLiteral(&DetailedHelp, "Pan View");
					ProfileStringArrayAddLiteral(&DetailedHelp, "Mouse Wheel");
					ProfileStringArrayAddLiteral(&DetailedHelp, "Zoom");
					ProfileDrawFloatWindow(nWidth, PROFILE_FRAME_HISTORY_HEIGHT + 20, DetailedHelp.ppStrings, DetailedHelp.nNumStrings, 0xff777777);

					ProfileStringArray DetailedHistoryHelp;
					ProfileStringArrayClear(&DetailedHistoryHelp);
					ProfileStringArrayFormat(&DetailedHistoryHelp, "%s", PROFILE_HELP_RIGHT);
					ProfileStringArrayAddLiteral(&DetailedHistoryHelp, "Center View");
					ProfileStringArrayFormat(&DetailedHistoryHelp, "%s", PROFILE_HELP_LEFT);
					ProfileStringArrayAddLiteral(&DetailedHistoryHelp, "Zoom to frame");
					ProfileDrawFloatWindow(nWidth, 20, DetailedHistoryHelp.ppStrings, DetailedHistoryHelp.nNumStrings, 0xff777777);
				}
				else if (0 != (S.nDisplay & P_DRAW_BARS) && S.nBars)
				{
					ProfileStringArray BarHelp;
					ProfileStringArrayClear(&BarHelp);
					ProfileStringArrayFormat(&BarHelp, "%s", PROFILE_HELP_RIGHT);
					ProfileStringArrayAddLiteral(&BarHelp, "Toggle Graph");
					ProfileStringArrayFormat(&BarHelp, "%s + %s", PROFILE_HELP_MOD, PROFILE_HELP_RIGHT);
					ProfileStringArrayAddLiteral(&BarHelp, "Lock Tooltip");
					ProfileStringArrayAddLiteral(&BarHelp, "Drag");
					ProfileStringArrayAddLiteral(&BarHelp, "Pan View");
					ProfileDrawFloatWindow(nWidth, PROFILE_FRAME_HISTORY_HEIGHT + 20, BarHelp.ppStrings, BarHelp.nNumStrings, 0xff777777);

				}
				ProfileStringArray Debug;
				ProfileStringArrayClear(&Debug);
				ProfileStringArrayAddLiteral(&Debug, "Memory Usage");
				ProfileStringArrayFormat(&Debug, "%4.2fmb", S.nMemUsage / (1024.f * 1024.f));
#if PROFILE_WEBSERVER
				ProfileStringArrayAddLiteral(&Debug, "Web Server Port");
				ProfileStringArrayFormat(&Debug, "%d", ProfileWebServerPort());
#endif
				uint32_t nFrameNext = (S.nFrameCurrent + 1) % PROFILE_MAX_FRAME_HISTORY;
				ProfileFrameState* pFrameCurrent = &S.Frames[S.nFrameCurrent];
				ProfileFrameState* pFrameNext = &S.Frames[nFrameNext];

				ProfileStringArrayAddLiteral(&Debug, "");
				ProfileStringArrayAddLiteral(&Debug, "");
				ProfileStringArrayAddLiteral(&Debug, "Usage");
				ProfileStringArrayAddLiteral(&Debug, "markers [frames] ");

#if PROFILE_CONTEXT_SWITCH_TRACE
				ProfileStringArrayAddLiteral(&Debug, "Context Switch");
				ProfileStringArrayFormat(&Debug, "%9d [%7d]", S.nContextSwitchUsage, PROFILE_CONTEXT_SWITCH_BUFFER_SIZE / S.nContextSwitchUsage);
#endif

				for (uint32_t i = 0; i < PROFILE_MAX_THREADS; ++i)
				{
					if (pFrameCurrent->nLogStart[i] && S.Pool[i])
					{
						uint32_t nEnd = pFrameNext->nLogStart[i];
						uint32_t nStart = pFrameCurrent->nLogStart[i];
						// volatile is a workaround for MSVC 2015 bug - compiler inserts cmov for the condition below despite the fact that RHS traps when nUsage==0
						volatile uint32_t nUsage = nStart <= nEnd ? (nEnd - nStart) : (nEnd + PROFILE_BUFFER_SIZE - nStart);
						uint32_t nFrameSupport = (nUsage == 0) ? PROFILE_BUFFER_SIZE : PROFILE_BUFFER_SIZE / nUsage;
						ProfileStringArrayFormat(&Debug, "%s", &S.Pool[i]->ThreadName[0]);
						ProfileStringArrayFormat(&Debug, "%9d [%7d]", nUsage, nFrameSupport);
					}
				}

				ProfileDrawFloatWindow(0, nHeight - 10, Debug.ppStrings, Debug.nNumStrings, 0xff777777);
			}



			if (UI.nActiveMenu == (uint32_t)-1 && !bMouseOverGraph)
			{
				if (UI.nHoverToken != PROFILE_INVALID_TOKEN)
				{
					ProfileDrawFloatTooltip(UI.nMouseX, UI.nMouseY, (uint32_t)UI.nHoverToken, UI.nHoverTime);
				}
				else if (S.nContextSwitchHoverThreadAfter != (ProfileThreadIdType)-1 && S.nContextSwitchHoverThreadBefore != (ProfileThreadIdType)-1)
				{
					#if defined(__APPLE__)
						#define THREAD_ID_FORMAT "%04llx"
					#elif defined(__ANDROID__)
						#if defined(__x86_64__) || defined(__aarch64__)
							#define THREAD_ID_FORMAT "%04lx"
						#else
							#define THREAD_ID_FORMAT "%04llx"
						#endif
					#else
						#define THREAD_ID_FORMAT "%04x"
					#endif

					float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu());
					ProfileStringArray ToolTip;
					ProfileStringArrayClear(&ToolTip);
					ProfileStringArrayAddLiteral(&ToolTip, "Context Switch");
					ProfileStringArrayFormat(&ToolTip, THREAD_ID_FORMAT, S.nContextSwitchHoverThread);
					ProfileStringArrayAddLiteral(&ToolTip, "Before");
					ProfileStringArrayFormat(&ToolTip, THREAD_ID_FORMAT, S.nContextSwitchHoverThreadBefore);
					ProfileStringArrayAddLiteral(&ToolTip, "After");
					ProfileStringArrayFormat(&ToolTip, THREAD_ID_FORMAT, S.nContextSwitchHoverThreadAfter);
					ProfileStringArrayAddLiteral(&ToolTip, "Duration");
					int64_t nDifference = ProfileLogTickDifference(S.nContextSwitchHoverTickIn, S.nContextSwitchHoverTickOut);
					ProfileStringArrayFormat(&ToolTip, "%6.2fms", fToMs * nDifference);
					ProfileStringArrayAddLiteral(&ToolTip, "CPU");
					ProfileStringArrayFormat(&ToolTip, "%d", S.nContextSwitchHoverCpu);
					ProfileDrawFloatWindow(UI.nMouseX, UI.nMouseY + 20, &ToolTip.ppStrings[0], ToolTip.nNumStrings, -1);

#undef THREAD_ID_FORMAT
				}
				else if (UI.nHoverFrame != -1)
				{
					uint32_t nNextFrame = (UI.nHoverFrame + 1) % PROFILE_MAX_FRAME_HISTORY;
					int64_t nTick = S.Frames[UI.nHoverFrame].nFrameStartCpu;
					int64_t nTickNext = S.Frames[nNextFrame].nFrameStartCpu;
					int64_t nTickGpu = S.Frames[UI.nHoverFrame].nFrameStartGpu;
					int64_t nTickNextGpu = S.Frames[nNextFrame].nFrameStartGpu;

					float fToMs = ProfileTickToMsMultiplier(ProfileTicksPerSecondCpu());
					float fToMsGpu = ProfileTickToMsMultiplier(ProfileTicksPerSecondGpu());
					float fMs = fToMs * (nTickNext - nTick);
					float fMsGpu = fToMsGpu * (nTickNextGpu - nTickGpu);
					ProfileStringArray ToolTip;
					ProfileStringArrayClear(&ToolTip);
					ProfileStringArrayFormat(&ToolTip, "Frame %d", UI.nHoverFrame);
#if PROFILE_DEBUG
					ProfileStringArrayFormat(&ToolTip, "%p", &S.Frames[UI.nHoverFrame]);
#else
					ProfileStringArrayAddLiteral(&ToolTip, "");
#endif
					ProfileStringArrayAddLiteral(&ToolTip, "CPU Time");
					ProfileStringArrayFormat(&ToolTip, "%6.2fms", fMs);
					ProfileStringArrayAddLiteral(&ToolTip, "GPU Time");
					ProfileStringArrayFormat(&ToolTip, "%6.2fms", fMsGpu);
#if PROFILE_DEBUG
					for (int i = 0; i < PROFILE_MAX_THREADS; ++i)
					{
						if (S.Frames[UI.nHoverFrame].nLogStart[i])
						{
							ProfileStringArrayFormat(&ToolTip, "%d", i);
							ProfileStringArrayFormat(&ToolTip, "%d", S.Frames[UI.nHoverFrame].nLogStart[i]);
						}
					}
#endif
					ProfileDrawFloatWindow(UI.nMouseX, UI.nMouseY + 20, &ToolTip.ppStrings[0], ToolTip.nNumStrings, -1);
				}
				if (UI.nMouseLeft)
				{
					if (UI.nHoverToken != PROFILE_INVALID_TOKEN)
						ProfileToggleGraph(UI.nHoverToken);
				}
			}
		}

#if PROFILE_DRAWCURSOR
		{
			float fCursor[8] =
			{
				float(ProfileMax(0, (int)UI.nMouseX - 3)), float(UI.nMouseY),
				float(ProfileMin(nWidth, UI.nMouseX + 3)), float(UI.nMouseY),
				float(UI.nMouseX), float(ProfileMax((int)UI.nMouseY - 3, 0)),
				float(UI.nMouseX), float(ProfileMin(nHeight, UI.nMouseY + 3)),
			};
			ProfileDrawLine2D(2, &fCursor[0], 0xff00ff00);
			ProfileDrawLine2D(2, &fCursor[4], 0xff00ff00);
		}
#endif
		m.unlock();
	}
	else if (UI.nCustomActive != (uint32_t)-1)
	{
		std::recursive_mutex& m = ProfileGetMutex();
		m.lock();
		ProfileDrawGraph(nWidth, nHeight);
		ProfileDrawCustom(nWidth, nHeight);
		m.unlock();

	}
	UI.nMouseLeft = UI.nMouseRight = 0;
	UI.nMouseLeftMod = UI.nMouseRightMod = 0;
	UI.nMouseWheelDelta = 0;
	if (S.nOverflow)
		S.nOverflow--;

	UI.fDetailedOffset = UI.fDetailedOffset + (UI.fDetailedOffsetTarget - UI.fDetailedOffset) * PROFILE_ANIM_DELAY_PRC;
	UI.fDetailedRange = UI.fDetailedRange + (UI.fDetailedRangeTarget - UI.fDetailedRange) * PROFILE_ANIM_DELAY_PRC;

	// End our own drawing
	ProfileEndDraw(pCmd);
}

bool ProfileIsDrawing()
{
	Profile& S = *ProfileGet();
	return S.nDisplay != 0;
}

void ProfileToggleGraph(ProfileToken nToken)
{
	Profile& S = *ProfileGet();
	uint32_t nTimerId = ProfileGetTimerIndex(nToken);
	nToken &= 0xffff;
	int32_t nMinSort = 0x7fffffff;
	int32_t nFreeIndex = -1;
	int32_t nMinIndex = 0;
	int32_t nMaxSort = 0x80000000;
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
	{
		if (S.Graph[i].nToken == PROFILE_INVALID_TOKEN)
			nFreeIndex = i;
		if (S.Graph[i].nToken == nToken)
		{
			S.Graph[i].nToken = PROFILE_INVALID_TOKEN;
			S.TimerInfo[nTimerId].bGraph = false;
			return;
		}
		if (S.Graph[i].nKey < nMinSort)
		{
			nMinSort = S.Graph[i].nKey;
			nMinIndex = i;
		}
		if (S.Graph[i].nKey > nMaxSort)
		{
			nMaxSort = S.Graph[i].nKey;
		}
	}
	int nIndex = nFreeIndex > -1 ? nFreeIndex : nMinIndex;
	if (nFreeIndex == -1)
	{
		uint32_t idx = ProfileGetTimerIndex(S.Graph[nIndex].nToken);
		S.TimerInfo[idx].bGraph = false;
	}
	S.Graph[nIndex].nToken = nToken;
	S.Graph[nIndex].nKey = nMaxSort + 1;
	memset(&S.Graph[nIndex].nHistory[0], 0, sizeof(S.Graph[nIndex].nHistory));
	S.TimerInfo[nTimerId].bGraph = true;
}

void ProfileModKey(uint32_t nKeyState)
{
    ProfileUI & UI = g_ProfileUI;
	UI.nModDown = nKeyState ? 1 : 0;
}

void ProfileClearGraph()
{
	Profile& S = *ProfileGet();
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
	{
		if (S.Graph[i].nToken != 0)
		{
			S.Graph[i].nToken = PROFILE_INVALID_TOKEN;
		}
	}
}

void ProfileMousePosition(uint32_t nX, uint32_t nY, int nWheelDelta)
{
    ProfileUI & UI = g_ProfileUI;
	UI.nMouseX = nX;
	UI.nMouseY = nY;
	UI.nMouseWheelDelta = nWheelDelta;
}

void ProfileMouseButton(uint32_t nLeft, uint32_t nRight)
{
    ProfileUI & UI = g_ProfileUI;
	bool bCanRelease = abs((int)(UI.nMouseDownX - UI.nMouseX)) + abs((int)(UI.nMouseDownY - UI.nMouseY)) < 3;

	if (0 == nLeft && UI.nMouseDownLeft && bCanRelease)
	{
		if (UI.nModDown)
			UI.nMouseLeftMod = 1;
		else
			UI.nMouseLeft = 1;
	}

	if (0 == nRight && UI.nMouseDownRight && bCanRelease)
	{
		if (UI.nModDown)
			UI.nMouseRightMod = 1;
		else
			UI.nMouseRight = 1;
	}
	if ((nLeft || nRight) && !(UI.nMouseDownLeft || UI.nMouseDownRight))
	{
		UI.nMouseDownX = UI.nMouseX;
		UI.nMouseDownY = UI.nMouseY;
	}

	UI.nMouseDownLeft = nLeft;
	UI.nMouseDownRight = nRight;

}

void ProfileDrawLineVertical(int nX, int nTop, int nBottom, uint32_t nColor)
{
	ProfileDrawBox(nX, nTop, nX + 1, nBottom, nColor, ProfileBoxTypeFlat);
}

void ProfileDrawLineHorizontal(int nLeft, int nRight, int nY, uint32_t nColor)
{
	ProfileDrawBox(nLeft, nY, nRight, nY + 1, nColor, ProfileBoxTypeFlat);
}



#include <stdio.h>

#define PROFILE_PRESET_HEADER_MAGIC 0x28586813
#define PROFILE_PRESET_HEADER_VERSION 0x00000102
struct ProfilePresetHeader
{
	uint32_t nMagic;
	uint32_t nVersion;
	//groups, threads, aggregate, reference frame, graphs timers
	uint32_t nGroups[PROFILE_MAX_GROUPS];
	uint32_t nThreads[PROFILE_MAX_THREADS];
	uint32_t nGraphName[PROFILE_MAX_GRAPHS];
	uint32_t nGraphGroupName[PROFILE_MAX_GRAPHS];
	uint32_t nAllGroupsWanted;
	uint32_t nAllThreadsWanted;
	uint32_t nAggregateFlip;
	float fReferenceTime;
	uint32_t nBars;
	uint32_t nDisplay;
	uint32_t nOpacityBackground;
	uint32_t nOpacityForeground;
	uint32_t nShowSpikes;
};

#ifndef PROFILE_PRESET_FILENAME_FUNC
#define PROFILE_PRESET_FILENAME_FUNC ProfilePresetFilename
static const char* ProfilePresetFilename(const char* pSuffix)
{
	static char filename[512];
	snprintf(filename, sizeof(filename) - 1, ".microprofilepreset.%s", pSuffix);
	return filename;
}
#endif

void ProfileSavePreset(const char* pPresetName)
{
	std::lock_guard<std::recursive_mutex> Lock(ProfileGetMutex());

    ProfileUI & UI = g_ProfileUI;
	File f;
	if (!f.Open(PROFILE_PRESET_FILENAME_FUNC(pPresetName), FileMode::FM_WriteBinary, FSR_Absolute))
	{
		return;
	}

	Profile& S = *ProfileGet();

	ProfilePresetHeader Header;
	memset(&Header, 0, sizeof(Header));
	Header.nAggregateFlip = S.nAggregateFlip;
	Header.nBars = S.nBars;
	Header.fReferenceTime = S.fReferenceTime;
	Header.nAllGroupsWanted = S.nAllGroupsWanted;
	Header.nAllThreadsWanted = S.nAllThreadsWanted;
	Header.nMagic = PROFILE_PRESET_HEADER_MAGIC;
	Header.nVersion = PROFILE_PRESET_HEADER_VERSION;
	Header.nDisplay = S.nDisplay;
	Header.nOpacityBackground = UI.nOpacityBackground;
	Header.nOpacityForeground = UI.nOpacityForeground;
	Header.nShowSpikes = UI.bShowSpikes ? 1 : 0;

	f.Write(&Header, sizeof(Header));

	uint64_t nMask = 1;
	for (uint32_t i = 0; i < PROFILE_MAX_GROUPS; ++i)
	{
		if (S.nActiveGroupWanted & nMask)
		{
			uint32_t offset = f.Tell();
			const char* pName = S.GroupInfo[i].pName;
			int nLen = (int)strlen(pName) + 1;
			f.Write(pName, nLen);
			Header.nGroups[i] = offset;
		}
		nMask <<= 1;
	}
	for (uint32_t i = 0; i < PROFILE_MAX_THREADS; ++i)
	{
		ProfileThreadLog* pLog = S.Pool[i];
		if (pLog && S.nThreadActive[i])
		{
			uint32_t offset = f.Tell();
			const char* pName = &pLog->ThreadName[0];
			int nLen = (int)strlen(pName) + 1;
			f.Write(pName, nLen);
			Header.nThreads[i] = offset;
		}
	}
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
	{
		ProfileToken nToken = S.Graph[i].nToken;
		if (nToken != PROFILE_INVALID_TOKEN)
		{
			uint32_t nGroupIndex = ProfileGetGroupIndex(nToken);
			uint32_t nTimerIndex = ProfileGetTimerIndex(nToken);
			const char* pGroupName = S.GroupInfo[nGroupIndex].pName;
			const char* pTimerName = S.TimerInfo[nTimerIndex].pName;
			ASSERT(pGroupName);
			ASSERT(pTimerName);
			int nGroupLen = (int)strlen(pGroupName) + 1;
			int nTimerLen = (int)strlen(pTimerName) + 1;

			uint32_t nOffsetGroup = f.Tell();
			f.Write(pGroupName, nGroupLen);
			uint32_t nOffsetTimer = f.Tell();
			f.Write(pTimerName, nTimerLen);
			Header.nGraphName[i] = nOffsetTimer;
			Header.nGraphGroupName[i] = nOffsetGroup;
		}
	}
	f.Seek(0, SEEK_DIR_BEGIN);
	f.Write(&Header, sizeof(Header));

	f.Close();

}



void ProfileLoadPreset(const char* pSuffix)
{
	std::lock_guard<std::recursive_mutex> Lock(ProfileGetMutex());
	File f;
    ProfileUI & UI = g_ProfileUI;

	if (!f.Open(PROFILE_PRESET_FILENAME_FUNC(pSuffix), FileMode::FM_ReadBinary, FSR_Absolute))
	{
		return;
	}

	f.Seek(0, SEEK_DIR_END);
	uint32_t nSize = f.Tell();
	char* const pBuffer = (char*)alloca(nSize);
	f.Seek(0, SEEK_DIR_CUR);
	int nRead = f.Read(pBuffer, nSize);
	f.Close();
	if (1 != nRead)
		return;

	Profile& S = *ProfileGet();

	ProfilePresetHeader& Header = *(ProfilePresetHeader*)pBuffer;

	if (Header.nMagic != PROFILE_PRESET_HEADER_MAGIC || Header.nVersion != PROFILE_PRESET_HEADER_VERSION)
	{
		return;
	}

	S.nAggregateFlip = Header.nAggregateFlip;
	S.nBars = Header.nBars;
	S.fReferenceTime = Header.fReferenceTime;
	S.fRcpReferenceTime = 1.f / Header.fReferenceTime;
	S.nAllGroupsWanted = Header.nAllGroupsWanted;
	S.nAllThreadsWanted = Header.nAllThreadsWanted;
	S.nDisplay = Header.nDisplay;
	S.nActiveGroupWanted = 0;
	UI.nOpacityBackground = Header.nOpacityBackground;
	UI.nOpacityForeground = Header.nOpacityForeground;
	UI.bShowSpikes = Header.nShowSpikes == 1;

	memset(&S.nThreadActive[0], 0, sizeof(S.nThreadActive));

	for (uint32_t i = 0; i < PROFILE_MAX_GROUPS; ++i)
	{
		if (Header.nGroups[i])
		{
			const char* pGroupName = pBuffer + Header.nGroups[i];
			for (uint32_t j = 0; j < PROFILE_MAX_GROUPS; ++j)
			{
				if (0 == P_STRCASECMP(pGroupName, S.GroupInfo[j].pName))
				{
					S.nActiveGroupWanted |= (1ll << j);
				}
			}
		}
	}
	for (uint32_t i = 0; i < PROFILE_MAX_THREADS; ++i)
	{
		if (Header.nThreads[i])
		{
			const char* pThreadName = pBuffer + Header.nThreads[i];
			for (uint32_t j = 0; j < PROFILE_MAX_THREADS; ++j)
			{
				ProfileThreadLog* pLog = S.Pool[j];
				if (pLog && 0 == P_STRCASECMP(pThreadName, &pLog->ThreadName[0]))
				{
					S.nThreadActive[j] = 1;
				}
			}
		}
	}
	for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
	{
		ProfileToken nPrevToken = S.Graph[i].nToken;
		S.Graph[i].nToken = PROFILE_INVALID_TOKEN;
		if (Header.nGraphName[i] && Header.nGraphGroupName[i])
		{
			const char* pGraphName = pBuffer + Header.nGraphName[i];
			const char* pGraphGroupName = pBuffer + Header.nGraphGroupName[i];
			for (uint32_t j = 0; j < S.nTotalTimers; ++j)
			{
				uint64_t nGroupIndex = S.TimerInfo[j].nGroupIndex;
				if (0 == P_STRCASECMP(pGraphName, S.TimerInfo[j].pName) && 0 == P_STRCASECMP(pGraphGroupName, S.GroupInfo[nGroupIndex].pName))
				{
					ProfileToken nToken = ProfileMakeToken(1ll << nGroupIndex, (uint16_t)j);
					S.Graph[i].nToken = nToken;			// note: group index is stored here but is checked without in ProfileToggleGraph()!
					S.TimerInfo[j].bGraph = true;
					if (nToken != nPrevToken)
					{
						memset(&S.Graph[i].nHistory, 0, sizeof(S.Graph[i].nHistory));
					}
					break;
				}
			}
		}
	}
}

uint32_t ProfileCustomGroupFind(const char* pCustomName)
{
    ProfileUI & UI = g_ProfileUI;
	for (uint32_t i = 0; i < UI.nCustomCount; ++i)
	{
		if (!P_STRCASECMP(pCustomName, UI.Custom[i].pName))
		{
			return i;
		}
	}
	return (uint32_t)-1;
}

uint32_t ProfileCustomGroup(const char* pCustomName)
{
    ProfileUI & UI = g_ProfileUI;
	for (uint32_t i = 0; i < UI.nCustomCount; ++i)
	{
		if (!P_STRCASECMP(pCustomName, UI.Custom[i].pName))
		{
			return i;
		}
	}
	ASSERT(UI.nCustomCount < PROFILE_CUSTOM_MAX);
	uint32_t nIndex = UI.nCustomCount;
	UI.nCustomCount++;
	memset(&UI.Custom[nIndex], 0, sizeof(UI.Custom[nIndex]));
	uint32_t nLen = (uint32_t)strlen(pCustomName);
	if (nLen > PROFILE_NAME_MAX_LEN - 1)
		nLen = PROFILE_NAME_MAX_LEN - 1;
	memcpy(&UI.Custom[nIndex].pName[0], pCustomName, nLen);
	UI.Custom[nIndex].pName[nLen] = '\0';
	return nIndex;
}
void ProfileCustomGroup(const char* pCustomName, uint32_t nMaxTimers, uint32_t nAggregateFlip, float fReferenceTime, uint32_t nFlags)
{
    ProfileUI & UI = g_ProfileUI;
	uint32_t nIndex = ProfileCustomGroup(pCustomName);
	ASSERT(UI.Custom[nIndex].pTimers == 0);//only call once!
	UI.Custom[nIndex].pTimers = &UI.CustomTimer[UI.nCustomTimerCount];
	UI.Custom[nIndex].nMaxTimers = nMaxTimers;
	UI.Custom[nIndex].fReference = fReferenceTime;
	UI.nCustomTimerCount += nMaxTimers;
	ASSERT(UI.nCustomTimerCount <= PROFILE_CUSTOM_MAX_TIMERS); //bump PROFILE_CUSTOM_MAX_TIMERS
	UI.Custom[nIndex].nFlags = nFlags;
	UI.Custom[nIndex].nAggregateFlip = nAggregateFlip;
}

void ProfileCustomGroupEnable(uint32_t nIndex)
{
    ProfileUI & UI = g_ProfileUI;
	if (nIndex < UI.nCustomCount)
	{
		Profile& S = *ProfileGet();
		S.nForceGroupUI = UI.Custom[nIndex].nGroupMask;
		ProfileSetAggregateFrames(UI.Custom[nIndex].nAggregateFlip);
		S.fReferenceTime = UI.Custom[nIndex].fReference;
		S.fRcpReferenceTime = 1.f / UI.Custom[nIndex].fReference;
		UI.nCustomActive = nIndex;

		for (uint32_t i = 0; i < PROFILE_MAX_GRAPHS; ++i)
		{
			if (S.Graph[i].nToken != PROFILE_INVALID_TOKEN)
			{
				uint32_t nTimerId = ProfileGetTimerIndex(S.Graph[i].nToken);
				S.TimerInfo[nTimerId].bGraph = false;
				S.Graph[i].nToken = PROFILE_INVALID_TOKEN;
			}
		}

		for (uint32_t i = 0; i < UI.Custom[nIndex].nNumTimers; ++i)
		{
			if (i == PROFILE_MAX_GRAPHS)
			{
				break;
			}
			S.Graph[i].nToken = UI.Custom[nIndex].pTimers[i];
			S.Graph[i].nKey = i;
			uint32_t nTimerId = ProfileGetTimerIndex(S.Graph[i].nToken);
			S.TimerInfo[nTimerId].bGraph = true;
		}
	}
}

void ProfileCustomGroupToggle(const char* pCustomName)
{
    ProfileUI & UI = g_ProfileUI;
	uint32_t nIndex = ProfileCustomGroupFind(pCustomName);
	if (nIndex == (uint32_t)-1 || nIndex == UI.nCustomActive)
	{
		ProfileCustomGroupDisable();
	}
	else
	{
		ProfileCustomGroupEnable(nIndex);
	}
}

void ProfileCustomGroupEnable(const char* pCustomName)
{
	uint32_t nIndex = ProfileCustomGroupFind(pCustomName);
	ProfileCustomGroupEnable(nIndex);
}
void ProfileCustomGroupDisable()
{
    ProfileUI & UI = g_ProfileUI;
	Profile& S = *ProfileGet();
	S.nForceGroupUI = 0;
	UI.nCustomActive = (uint32_t)-1;
}

void ProfileCustomGroupAddTimer(const char* pCustomName, const char* pGroup, const char* pTimer)
{
    ProfileUI & UI = g_ProfileUI;
	uint32_t nIndex = ProfileCustomGroupFind(pCustomName);
	if ((uint32_t)-1 == nIndex)
	{
		return;
	}
	uint32_t nTimerIndex = UI.Custom[nIndex].nNumTimers;
	ASSERT(nTimerIndex < UI.Custom[nIndex].nMaxTimers);
	uint64_t nToken = ProfileFindToken(pGroup, pTimer);
	ASSERT(nToken != PROFILE_INVALID_TOKEN); //Timer must be registered first.
	UI.Custom[nIndex].pTimers[nTimerIndex] = nToken;
	uint16_t nGroup = ProfileGetGroupIndex(nToken);
	UI.Custom[nIndex].nGroupMask |= (1ll << nGroup);
	UI.Custom[nIndex].nNumTimers++;
}

bool ProfileIsDetailed()
{
	return ProfileGet()->nDisplay & P_DRAW_DETAILED;
}

#endif
